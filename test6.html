<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>LangAssist - AI Language Learning Assistant</title>
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css"
    />
    <style>
      :root {
        --primary: #2563eb;
        --primary-dark: #1d4ed8;
        --success: #10b981;
        --error: #ef4444;
        --warning: #f59e0b;
        --bg: #f8fafc;
        --card: #ffffff;
        --border: #e2e8f0;
        --text: #1e293b;
        --text-muted: #64748b;
        --shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1),
          0 1px 2px 0 rgba(0, 0, 0, 0.06);
      }

      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
          sans-serif;
        background: var(--bg);
        color: var(--text);
        line-height: 1.6;
      }

      .container {
        max-width: 1400px;
        margin: 0 auto;
        padding: 20px;
        display: grid;
        grid-template-columns: 1fr 350px;
        gap: 20px;
      }

      @media (max-width: 1024px) {
        .container {
          grid-template-columns: 1fr;
        }

        .sidebar {
          order: 2;
        }
      }

      .main-content {
        min-width: 0;
      }

      .header {
        background: var(--card);
        padding: 20px;
        border-radius: 12px;
        box-shadow: var(--shadow);
        margin-bottom: 20px;
        display: flex;
        justify-content: space-between;
        align-items: center;
        flex-wrap: wrap;
        gap: 15px;
      }

      .header h1 {
        color: var(--primary);
        font-size: 1.8rem;
        font-weight: 700;
      }

      .header-controls {
        display: flex;
        gap: 15px;
        align-items: center;
        flex-wrap: wrap;
      }

      .status-indicator {
        display: flex;
        align-items: center;
        gap: 8px;
        font-size: 0.9rem;
      }

      .status-dot {
        width: 10px;
        height: 10px;
        border-radius: 50%;
        background: var(--text-muted);
      }

      .status-dot.connected {
        background: var(--success);
      }

      .status-dot.error {
        background: var(--error);
      }

      .btn {
        padding: 8px 16px;
        border: none;
        border-radius: 6px;
        cursor: pointer;
        font-size: 0.9rem;
        font-weight: 500;
        transition: all 0.2s;
        display: inline-flex;
        align-items: center;
        gap: 6px;
      }

      .btn:disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }

      .btn-primary {
        background: var(--primary);
        color: white;
      }

      .btn-primary:hover:not(:disabled) {
        background: var(--primary-dark);
      }

      .btn-secondary {
        background: var(--border);
        color: var(--text);
      }

      .btn-secondary:hover:not(:disabled) {
        background: #cbd5e1;
      }

      .btn-ghost {
        background: transparent;
        color: var(--text-muted);
        border: 1px solid var(--border);
      }

      .btn-ghost:hover:not(:disabled) {
        background: var(--bg);
        color: var(--text);
      }

      .btn-success {
        background: var(--success);
        color: white;
      }

      .btn-danger {
        background: var(--error);
        color: white;
      }

      .btn-warning {
        background: var(--warning);
        color: white;
      }

      .tabs {
        background: var(--card);
        border-radius: 12px;
        box-shadow: var(--shadow);
        overflow: hidden;
        margin-bottom: 20px;
      }

      .tab-header {
        display: flex;
        background: var(--bg);
        border-bottom: 1px solid var(--border);
        overflow-x: auto;
      }

      .tab {
        padding: 15px 20px;
        cursor: pointer;
        border: none;
        background: none;
        color: var(--text-muted);
        font-size: 0.9rem;
        font-weight: 500;
        transition: all 0.2s;
        border-bottom: 2px solid transparent;
        white-space: nowrap;
      }

      .tab.active {
        color: var(--primary);
        border-bottom-color: var(--primary);
        background: var(--card);
      }

      .tab:hover:not(.active) {
        color: var(--text);
      }

      .tab-content {
        display: none;
        padding: 20px;
      }

      .tab-content.active {
        display: block;
      }

      .form-group {
        margin-bottom: 20px;
      }

      .form-group label {
        display: block;
        margin-bottom: 6px;
        font-weight: 500;
        color: var(--text);
      }

      .form-control {
        width: 100%;
        padding: 10px 12px;
        border: 1px solid var(--border);
        border-radius: 6px;
        font-size: 0.9rem;
        transition: border-color 0.2s;
      }

      .form-control:focus {
        outline: none;
        border-color: var(--primary);
        box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.1);
      }

      select.form-control {
        cursor: pointer;
      }

      textarea.form-control {
        resize: vertical;
        min-height: 100px;
      }

      .form-row {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 15px;
      }

      @media (max-width: 768px) {
        .form-row {
          grid-template-columns: 1fr;
        }
      }

      .recording-section {
        background: var(--bg);
        padding: 20px;
        border-radius: 8px;
        margin-bottom: 20px;
      }

      .recording-controls {
        display: flex;
        gap: 10px;
        align-items: center;
        flex-wrap: wrap;
        margin-bottom: 15px;
      }

      .recording-timer {
        font-family: "Courier New", monospace;
        font-size: 1.2rem;
        font-weight: bold;
        color: var(--primary);
        margin-left: 10px;
      }

      .audio-meter {
        flex: 1;
        height: 8px;
        background: var(--border);
        border-radius: 4px;
        overflow: hidden;
        margin: 0 15px;
      }

      .audio-meter-fill {
        height: 100%;
        background: var(--success);
        width: 0%;
        transition: width 0.1s;
      }

      .sidebar {
        display: flex;
        flex-direction: column;
        gap: 20px;
      }

      .sidebar-section {
        background: var(--card);
        border-radius: 12px;
        box-shadow: var(--shadow);
        padding: 20px;
      }

      .sidebar-section h3 {
        font-size: 1.1rem;
        margin-bottom: 15px;
        display: flex;
        align-items: center;
        gap: 8px;
      }

      .sidebar-response {
        border: 1px solid var(--border);
        border-radius: 8px;
        padding: 12px;
        margin-bottom: 10px;
        background: var(--bg);
        cursor: pointer;
        transition: all 0.2s;
      }

      .sidebar-response:hover {
        border-color: var(--primary);
        box-shadow: 0 2px 4px rgba(37, 99, 235, 0.1);
      }

      .sidebar-response-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 8px;
      }

      .sidebar-response-type {
        background: var(--primary);
        color: white;
        padding: 2px 6px;
        border-radius: 4px;
        font-size: 0.75rem;
        font-weight: 500;
      }

      .sidebar-response-time {
        color: var(--text-muted);
        font-size: 0.75rem;
      }

      .sidebar-response-content {
        font-size: 0.85rem;
        color: var(--text);
        overflow: hidden;
        text-overflow: ellipsis;
        display: -webkit-box;
        -webkit-line-clamp: 2;
        -webkit-box-orient: vertical;
      }

      .sidebar-empty {
        text-align: center;
        color: var(--text-muted);
        font-size: 0.9rem;
        padding: 20px;
      }

      .responses-section {
        background: var(--card);
        border-radius: 12px;
        box-shadow: var(--shadow);
        padding: 20px;
      }

      .responses-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 20px;
        flex-wrap: wrap;
        gap: 15px;
      }

      .responses-header h2 {
        font-size: 1.3rem;
        font-weight: 600;
      }

      .responses-controls {
        display: flex;
        gap: 10px;
        align-items: center;
        flex-wrap: wrap;
      }

      .response-item {
        border: 1px solid var(--border);
        border-radius: 8px;
        margin-bottom: 15px;
        overflow: hidden;
        background: var(--card);
      }

      .response-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 12px 15px;
        background: var(--bg);
        border-bottom: 1px solid var(--border);
      }

      .response-meta {
        display: flex;
        gap: 15px;
        align-items: center;
      }

      .response-type {
        background: var(--primary);
        color: white;
        padding: 2px 8px;
        border-radius: 4px;
        font-size: 0.8rem;
        font-weight: 500;
      }

      .response-time {
        color: var(--text-muted);
        font-size: 0.8rem;
      }

      .response-status {
        padding: 4px 8px;
        border-radius: 4px;
        font-size: 0.8rem;
        font-weight: 500;
      }

      .response-status.success {
        background: rgba(16, 185, 129, 0.1);
        color: var(--success);
      }

      .response-status.error {
        background: rgba(239, 68, 68, 0.1);
        color: var(--error);
      }

      .response-content {
        padding: 15px;
        white-space: pre-wrap;
        font-family: "Monaco", "Courier New", monospace;
        font-size: 0.9rem;
        line-height: 1.5;
        background: #f9fafb;
        max-height: 300px;
        overflow-y: auto;
      }

      .response-actions {
        padding: 12px 15px;
        background: var(--bg);
        border-top: 1px solid var(--border);
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
      }

      .binary-audio-indicator {
        padding: 15px;
        background: linear-gradient(
          135deg,
          rgba(37, 99, 235, 0.05),
          rgba(16, 185, 129, 0.05)
        );
        border-left: 4px solid var(--primary);
        display: flex;
        align-items: center;
        gap: 12px;
      }

      .binary-audio-indicator i {
        font-size: 1.5rem;
        color: var(--primary);
      }

      .modal {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.5);
        z-index: 1000;
        backdrop-filter: blur(4px);
      }

      .modal.active {
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 20px;
      }

      .modal-content {
        background: var(--card);
        border-radius: 12px;
        max-width: 600px;
        width: 100%;
        max-height: 90vh;
        overflow-y: auto;
      }

      .modal-header {
        padding: 20px;
        border-bottom: 1px solid var(--border);
        display: flex;
        justify-content: space-between;
        align-items: center;
      }

      .modal-header h2 {
        margin: 0;
        font-size: 1.3rem;
      }

      .close-btn {
        background: none;
        border: none;
        font-size: 1.5rem;
        cursor: pointer;
        color: var(--text-muted);
        padding: 5px;
      }

      .modal-body {
        padding: 20px;
      }

      .modal-footer {
        padding: 20px;
        border-top: 1px solid var(--border);
        display: flex;
        gap: 10px;
        justify-content: flex-end;
      }

      .checkbox {
        display: flex;
        align-items: center;
        gap: 8px;
        margin: 10px 0;
      }

      .checkbox input[type="checkbox"] {
        width: 16px;
        height: 16px;
        accent-color: var(--primary);
      }

      .file-input-wrapper {
        position: relative;
        display: inline-block;
        cursor: pointer;
      }

      .file-input-wrapper input[type="file"] {
        position: absolute;
        opacity: 0;
        width: 100%;
        height: 100%;
        cursor: pointer;
      }

      .text-muted {
        color: var(--text-muted);
      }

      .text-sm {
        font-size: 0.8rem;
      }

      .webhook-display {
        font-family: monospace;
        background: var(--bg);
        padding: 8px 12px;
        border-radius: 4px;
        border: 1px solid var(--border);
        word-break: break-all;
        font-size: 0.85rem;
      }

      #customLangInput {
        display: none;
        margin-top: 8px;
      }

      .processing-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.7);
        z-index: 999;
        display: none;
        align-items: center;
        justify-content: center;
        backdrop-filter: blur(4px);
      }

      .processing-overlay.active {
        display: flex;
      }

      .processing-content {
        background: var(--card);
        padding: 30px 40px;
        border-radius: 12px;
        text-align: center;
        box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
      }

      .processing-spinner {
        width: 50px;
        height: 50px;
        border: 4px solid var(--border);
        border-top-color: var(--primary);
        border-radius: 50%;
        animation: spin 1s linear infinite;
        margin: 0 auto 20px;
      }

      @keyframes spin {
        to {
          transform: rotate(360deg);
        }
      }

      .processing-text {
        font-size: 1.1rem;
        font-weight: 500;
        color: var(--text);
      }

      @keyframes pulse {
        0% {
          opacity: 1;
        }

        50% {
          opacity: 0.5;
        }

        100% {
          opacity: 1;
        }
      }
    </style>
  </head>

  <body>
    <div class="container">
      <div class="main-content">
        <header class="header">
          <h1><i class="fas fa-language"></i> LangAssist</h1>
          <div class="header-controls">
            <div class="status-indicator">
              <div id="connDot" class="status-dot"></div>
              <span id="connText">Unknown</span>
            </div>
            <button id="settingsBtn" class="btn btn-secondary">
              <i class="fas fa-cog"></i> Settings
            </button>
            <button id="testConn" class="btn btn-primary">
              <i class="fas fa-plug"></i> Test Connection
            </button>
          </div>
        </header>

        <div class="tabs">
          <div class="tab-header">
            <button class="tab active" data-tab="text">
              <i class="fas fa-edit"></i> Text Assist
            </button>
            <button class="tab" data-tab="voice">
              <i class="fas fa-microphone"></i> Voice Assistant
            </button>
            <button class="tab" data-tab="practice">
              <i class="fas fa-graduation-cap"></i> Practice Mode
            </button>
            <button class="tab" data-tab="responses">
              <i class="fas fa-history"></i> Responses
            </button>
          </div>

          <div id="text-content" class="tab-content active">
            <div class="form-row">
              <div class="form-group">
                <label for="action">Action</label>
                <select id="action" class="form-control">
                  <option value="translate">Translate</option>
                  <option value="correct">Grammar Correction</option>
                  <option value="summarize">Summarize</option>
                  <option value="explain">Explain</option>
                  <option value="rephrase">Rephrase</option>
                </select>
              </div>
              <div class="form-group">
                <label for="tone">Tone/Style</label>
                <select id="tone" class="form-control">
                  <option value="neutral">Neutral</option>
                  <option value="formal">Formal</option>
                  <option value="casual">Casual</option>
                  <option value="professional">Professional</option>
                  <option value="friendly">Friendly</option>
                </select>
              </div>
            </div>
            <div class="form-row">
              <div class="form-group">
                <label for="inputLang">Input Language</label>
                <select id="inputLang" class="form-control">
                  <option value="auto">Auto-detect</option>
                  <option value="English">English</option>
                  <option value="Spanish">Spanish</option>
                  <option value="French">French</option>
                  <option value="Kannada">Kannada</option>
                  <option value="German">German</option>
                  <option value="Italian">Italian</option>
                  <option value="Portuguese">Portuguese</option>
                  <option value="Russian">Russian</option>
                  <option value="Chinese">Chinese</option>
                  <option value="Japanese">Japanese</option>
                  <option value="Korean">Korean</option>
                  <option value="Hindi">Hindi</option>
                </select>
              </div>
              <div class="form-group">
                <label for="targetLang">Target Language</label>
                <select id="targetLang" class="form-control">
                  <option value="English">English</option>
                  <option value="Spanish">Spanish</option>
                  <option value="French">French</option>
                  <option value="Kannada">Kannada</option>
                  <option value="German">German</option>
                  <option value="Italian">Italian</option>
                  <option value="Portuguese">Portuguese</option>
                  <option value="Russian">Russian</option>
                  <option value="Chinese">Chinese</option>
                  <option value="Japanese">Japanese</option>
                  <option value="Korean">Korean</option>
                  <option value="Hindi">Hindi</option>
                  <option value="custom">&lt;Custom Language&gt;</option>
                </select>
                <input
                  type="text"
                  id="customLangInput"
                  class="form-control"
                  placeholder="Enter custom language..."
                />
              </div>
            </div>
            <div class="form-group">
              <label for="userId">User ID (optional)</label>
              <input
                type="text"
                id="userId"
                class="form-control"
                placeholder="Enter user identifier"
              />
            </div>
            <div class="form-group">
              <label for="textToProcess">Text to Process</label>
              <textarea
                id="textToProcess"
                class="form-control"
                placeholder="Enter your text here... (Ctrl+Enter to send)"
                rows="6"
              ></textarea>
            </div>
            <div style="display: flex; gap: 10px; justify-content: flex-end">
              <button id="clearText" class="btn btn-secondary">
                <i class="fas fa-eraser"></i> Clear
              </button>
              <button id="sendText" class="btn btn-primary">
                <i class="fas fa-paper-plane"></i> Send
              </button>
            </div>
          </div>

          <div id="voice-content" class="tab-content">
            <div class="recording-section">
              <h3 style="margin-bottom: 15px">
                <i class="fas fa-microphone"></i> Record Audio
              </h3>
              <div class="recording-controls">
                <button id="recBtn" class="btn btn-primary">
                  <i class="fas fa-record-vinyl"></i> Start Recording
                </button>
                <button id="pauseRec" class="btn btn-warning" disabled>
                  <i class="fas fa-pause"></i> Pause
                </button>
                <button id="stopRec" class="btn btn-danger" disabled>
                  <i class="fas fa-stop"></i> Stop
                </button>
                <span id="recTimer" class="recording-timer">00:00</span>
              </div>
              <div class="audio-meter">
                <div id="meterFill" class="audio-meter-fill"></div>
              </div>
              <div class="recording-controls">
                <button id="playRec" class="btn btn-secondary" disabled>
                  <i class="fas fa-play"></i> Play
                </button>
                <button
                  id="pauseRecBtn"
                  class="btn btn-warning"
                  disabled
                  style="display: none"
                >
                  <i class="fas fa-pause"></i> Pause
                </button>
                <button
                  id="resumeRecBtn"
                  class="btn btn-success"
                  disabled
                  style="display: none"
                >
                  <i class="fas fa-play"></i> Resume
                </button>
                <button id="downloadRec" class="btn btn-ghost" disabled>
                  <i class="fas fa-download"></i> Download
                </button>
                <div class="form-group" style="margin: 0; min-width: 120px">
                  <select id="recordFormat" class="form-control">
                    <option value="webm">WebM</option>
                    <option value="wav">WAV</option>
                    <option value="ogg">OGG</option>
                  </select>
                </div>
              </div>
            </div>

            <div class="form-group">
              <label for="audioFile">Or Upload Audio File</label>
              <div class="file-input-wrapper">
                <input
                  type="file"
                  id="audioFile"
                  accept="audio/*"
                  class="form-control"
                />
                <div
                  class="btn btn-secondary"
                  style="width: 100%; justify-content: center"
                >
                  <i class="fas fa-upload"></i> Choose Audio File
                </div>
              </div>
              <small class="text-muted">Max file size: 10MB</small>
            </div>

            <div class="checkbox">
              <input type="checkbox" id="useMultipart" />
              <label for="useMultipart"
                >Use multipart/form-data (recommended for large files)</label
              >
            </div>

            <div
              style="
                display: flex;
                gap: 10px;
                justify-content: flex-end;
                margin-top: 20px;
              "
            >
              <button id="sendAudio" class="btn btn-primary">
                <i class="fas fa-paper-plane"></i> Send Audio
              </button>
            </div>
          </div>

          <div id="practice-content" class="tab-content">
            <div class="form-group">
              <label for="practiceMode">Practice Mode</label>
              <select id="practiceMode" class="form-control">
                <option value="custom">Custom Text</option>
                <option value="tonguetwister">Tongue Twister Generator</option>
              </select>
            </div>

            <div id="customTextSection">
              <div class="form-group">
                <label for="practiceText">Text to Practice</label>
                <textarea
                  id="practiceText"
                  class="form-control"
                  placeholder="Enter text you want to practice pronouncing..."
                  rows="4"
                ></textarea>
              </div>
            </div>

            <div id="tongueTwisterSection" style="display: none">
              <div class="form-row">
                <div class="form-group">
                  <label for="ttLanguage">Language</label>
                  <select id="ttLanguage" class="form-control">
                    <option value="English">English</option>
                    <option value="Spanish">Spanish</option>
                    <option value="French">French</option>
                    <option value="Kannada">Kannada</option>
                    <option value="Hindi">Hindi</option>
                    <option value="German">German</option>
                    <option value="Italian">Italian</option>
                    <option value="Portuguese">Portuguese</option>
                    <option value="Russian">Russian</option>
                    <option value="Chinese">Chinese</option>
                    <option value="Japanese">Japanese</option>
                    <option value="Korean">Korean</option>
                  </select>
                </div>
                <div class="form-group">
                  <label for="ttLevel">Difficulty Level</label>
                  <select id="ttLevel" class="form-control">
                    <option value="easy">Easy</option>
                    <option value="medium">Medium</option>
                    <option value="hard">Hard</option>
                    <option value="expert">Expert</option>
                  </select>
                </div>
              </div>

              <button
                id="generateTT"
                class="btn btn-secondary"
                style="margin-bottom: 15px"
              >
                <i class="fas fa-magic"></i> Generate Tongue Twister
              </button>

              <div id="generatedTTContainer" style="display: none">
                <div class="form-group">
                  <label>Generated Tongue Twister</label>
                  <div
                    id="generatedTT"
                    style="
                      background: var(--bg);
                      padding: 15px;
                      border-radius: 8px;
                      border: 1px solid var(--border);
                      margin-bottom: 10px;
                      font-size: 1.1rem;
                      line-height: 1.6;
                    "
                  ></div>
                  <button id="regenerateTT" class="btn btn-ghost">
                    <i class="fas fa-sync"></i> Generate Another
                  </button>
                </div>
              </div>
            </div>

            <div class="recording-controls" style="margin-top: 20px">
              <button id="startPractice" class="btn btn-primary">
                <i class="fas fa-microphone"></i> Start Practice
              </button>
              <button id="stopPractice" class="btn btn-danger" disabled>
                <i class="fas fa-stop"></i> Stop & Analyze
              </button>
            </div>

            <div class="text-muted text-sm" style="margin-top: 15px">
              Choose between custom text or AI-generated tongue twisters. Record
              yourself speaking, and the system will analyze your pronunciation
              and provide feedback.
            </div>
          </div>

          <div id="responses-content" class="tab-content">
            <div class="responses-header">
              <h2>Response History</h2>
              <div class="responses-controls">
                <div class="checkbox">
                  <input type="checkbox" id="rawToggle" />
                  <label for="rawToggle">Raw JSON</label>
                </div>
                <div class="checkbox">
                  <input type="checkbox" id="showRaw" />
                  <label for="showRaw">Show Raw Data</label>
                </div>
                <button id="playbackTTS" class="btn btn-secondary">
                  <i class="fas fa-play"></i> Play Last Response
                </button>
                <button id="downloadAll" class="btn btn-ghost">
                  <i class="fas fa-download"></i> Export All
                </button>
                <button id="clearResponses" class="btn btn-danger">
                  <i class="fas fa-trash"></i> Clear All
                </button>
                <span class="text-muted"
                  >Retries: <span id="retryCount">0</span></span
                >
              </div>
            </div>
            <div id="responses"></div>
          </div>
        </div>
      </div>

      <div class="sidebar">
        <div class="sidebar-section">
          <h3><i class="fas fa-clock"></i> Recent Responses</h3>
          <div id="sidebarResponses"></div>
        </div>
      </div>
    </div>

    <div id="modal" class="modal">
      <div class="modal-content">
        <div class="modal-header">
          <h2><i class="fas fa-cog"></i> Settings</h2>
          <button id="closeSettings" class="close-btn">&times;</button>
        </div>
        <div class="modal-body">
          <div class="form-group">
            <label for="settingWebhook">Webhook URL</label>
            <input
              type="url"
              id="settingWebhook"
              class="form-control"
              placeholder="https://your-n8n-instance.com/webhook/langassist"
            />
          </div>
          <div class="form-group">
            <label for="settingApiKey">API Key (optional)</label>
            <input
              type="password"
              id="settingApiKey"
              class="form-control"
              placeholder="Your API key"
            />
          </div>
          <div class="form-group">
            <label for="settingLangs"
              >Supported Languages (comma-separated)</label
            >
            <input
              type="text"
              id="settingLangs"
              class="form-control"
              placeholder="English,Spanish,Kannada,French"
            />
          </div>

          <div class="form-group">
            <label for="settingGeminiKey"
              >Gemini API Key (for Practice Mode)</label
            >
            <input
              type="password"
              id="settingGeminiKey"
              class="form-control"
              placeholder="Your Gemini API key"
            />
            <small class="text-muted"
              >Get your key from
              <a href="https://aistudio.google.com/app/apikey" target="_blank"
                >Google AI Studio</a
              ></small
            >
          </div>

          <div class="form-group">
            <label>Current Webhook:</label>
            <div id="currentWebhook" class="webhook-display">
              (no webhook configured)
            </div>
          </div>
          <button id="settingsTest" class="btn btn-secondary">
            <i class="fas fa-flask"></i>
            <span id="settingsPing">Test Connection</span>
          </button>
        </div>
        <div class="modal-footer">
          <button id="resetSettings" class="btn btn-secondary">
            <i class="fas fa-undo"></i> Reset to Defaults
          </button>
          <button id="saveSettings" class="btn btn-primary">
            <i class="fas fa-save"></i> Save Settings
          </button>
        </div>
      </div>
    </div>

    <div id="processingOverlay" class="processing-overlay">
      <div class="processing-content">
        <div class="processing-spinner"></div>
        <div class="processing-text">Analyzing your pronunciation...</div>
      </div>
    </div>

    <script>
      (() => {
        const $ = (sel) => document.querySelector(sel);
        const id = (s) => document.getElementById(s);
        const SETTINGS_KEY = "langassist.settings";
        const RESPONSES_KEY = "langassist.responses";

        function loadSettings() {
          const defaultSettings = {
            webhook: "https://n8n-s73k.onrender.com/webhook-test/audio-echo",
            apiKey: "",
            langs: "English,Spanish,Kannada,Hindi",
            geminiKey: "AIzaSyDRDiPaH8HP34bNKUV5qSDImyYVASTm16o",
          };

          try {
            const stored = JSON.parse(
              localStorage.getItem(SETTINGS_KEY) || "{}"
            );
            return { ...defaultSettings, ...stored };
          } catch (e) {
            return defaultSettings;
          }
        }

        function saveSettings(settings) {
          localStorage.setItem(SETTINGS_KEY, JSON.stringify(settings));
        }

        function loadResponses() {
          try {
            return JSON.parse(localStorage.getItem(RESPONSES_KEY) || "[]");
          } catch (e) {
            return [];
          }
        }

        function saveResponses(responses) {
          localStorage.setItem(RESPONSES_KEY, JSON.stringify(responses));
        }

        function getCurrentSection() {
          const activeTab = document.querySelector(".tab.active");
          if (!activeTab) return "Unknown";

          const tabName = activeTab.getAttribute("data-tab");
          const sectionNames = {
            text: "Text Assist",
            voice: "Voice Assistant",
            practice: "Practice Mode",
            responses: "Responses",
          };

          return sectionNames[tabName] || "Unknown";
        }

        function isBinaryAudioData(obj) {
          if (!obj || typeof obj !== "object") return false;

          if (obj.file && obj.file.data && obj.file.mimeType) {
            return (
              obj.file.mimeType.startsWith("audio/") ||
              obj.file.mimeType.startsWith("video/webm")
            );
          }

          if (obj.data && obj.mimeType) {
            return (
              obj.mimeType.startsWith("audio/") ||
              obj.mimeType.startsWith("video/webm")
            );
          }

          if (obj.type === "Buffer" && Array.isArray(obj.data)) {
            return true;
          }

          if (obj.binary && typeof obj.binary === "object") {
            return Object.values(obj.binary).some(
              (item) =>
                item &&
                item.mimeType &&
                (item.mimeType.startsWith("audio/") ||
                  item.mimeType.startsWith("video/webm"))
            );
          }

          if (
            obj.data &&
            typeof obj.data === "string" &&
            obj.data.length > 100 &&
            obj.mimeType
          ) {
            return (
              obj.mimeType.startsWith("audio/") ||
              obj.mimeType.startsWith("video/webm")
            );
          }

          const keys = Object.keys(obj);
          if (keys.length < 50) return false;

          const numericKeys = keys.filter((k) => /^\d+$/.test(k));
          if (numericKeys.length !== keys.length) return false;

          const indices = numericKeys
            .map((k) => parseInt(k))
            .sort((a, b) => a - b);
          const isSequential = indices.length > 0 && indices[0] === 0;
          if (!isSequential) return false;

          for (let i = 1; i < Math.min(indices.length, 100); i++) {
            if (indices[i] !== indices[i - 1] + 1) {
              return false;
            }
          }

          const sampleKeys = keys.slice(0, 20);
          const hasBytePattern = sampleKeys.every((k) => {
            const val = obj[k];
            return (
              typeof val === "number" &&
              val >= 0 &&
              val <= 255 &&
              Number.isInteger(val)
            );
          });

          return hasBytePattern;
        }

        function detectAudioFormat(bytes) {
          if (bytes.length < 4) return "audio/webm";

          const header = bytes.slice(0, 12);

          if (
            header[0] === 0x1a &&
            header[1] === 0x45 &&
            header[2] === 0xdf &&
            header[3] === 0xa3
          ) {
            return "audio/webm";
          }

          if (
            header[0] === 0x4f &&
            header[1] === 0x67 &&
            header[2] === 0x67 &&
            header[3] === 0x53
          ) {
            return "audio/ogg";
          }

          if (
            header[0] === 0x52 &&
            header[1] === 0x49 &&
            header[2] === 0x46 &&
            header[3] === 0x46
          ) {
            return "audio/wav";
          }

          if (header[0] === 0xff && (header[1] & 0xe0) === 0xe0) {
            return "audio/mpeg";
          }

          if (
            header[4] === 0x66 &&
            header[5] === 0x74 &&
            header[6] === 0x79 &&
            header[7] === 0x70
          ) {
            return "audio/mp4";
          }

          if (
            header[0] === 0x66 &&
            header[1] === 0x4c &&
            header[2] === 0x61 &&
            header[3] === 0x43
          ) {
            return "audio/flac";
          }

          return "audio/webm";
        }

        function convertBinaryDataToBlob(binaryData) {
          try {
            let bytes = [];
            let mimeType = "audio/webm";

            if (
              binaryData.file &&
              binaryData.file.data &&
              binaryData.file.mimeType
            ) {
              mimeType = binaryData.file.mimeType;
              const base64Data = binaryData.file.data;

              try {
                const binaryString = atob(base64Data);
                bytes = new Array(binaryString.length);
                for (let i = 0; i < binaryString.length; i++) {
                  bytes[i] = binaryString.charCodeAt(i);
                }
                const uint8Array = new Uint8Array(bytes);
                return new Blob([uint8Array], { type: mimeType });
              } catch (e) {
                console.error(
                  "Failed to decode base64 data from file object:",
                  e
                );
                return null;
              }
            }

            if (binaryData.binary && typeof binaryData.binary === "object") {
              const binaryKeys = Object.keys(binaryData.binary);
              if (binaryKeys.length > 0) {
                const firstBinary = binaryData.binary[binaryKeys[0]];
                return convertBinaryDataToBlob(firstBinary);
              }
            }

            if (binaryData.data && binaryData.mimeType) {
              mimeType = binaryData.mimeType;

              if (
                binaryData.data.type === "Buffer" &&
                Array.isArray(binaryData.data.data)
              ) {
                bytes = binaryData.data.data;
              } else if (typeof binaryData.data === "string") {
                try {
                  const binaryString = atob(binaryData.data);
                  bytes = new Array(binaryString.length);
                  for (let i = 0; i < binaryString.length; i++) {
                    bytes[i] = binaryString.charCodeAt(i);
                  }
                } catch (e) {
                  console.warn(
                    "Failed to decode base64 data, treating as raw string"
                  );
                  bytes = Array.from(binaryData.data).map((c) =>
                    c.charCodeAt(0)
                  );
                }
              } else if (typeof binaryData.data === "object") {
                const keys = Object.keys(binaryData.data).sort(
                  (a, b) => parseInt(a) - parseInt(b)
                );
                bytes = keys.map((k) => binaryData.data[k]);
              }

              const uint8Array = new Uint8Array(bytes);
              return new Blob([uint8Array], { type: mimeType });
            }

            if (
              binaryData.type === "Buffer" &&
              Array.isArray(binaryData.data)
            ) {
              bytes = binaryData.data;
              const uint8Array = new Uint8Array(bytes);

              if (bytes.length > 4) {
                mimeType = detectAudioFormat(bytes);
              }

              return new Blob([uint8Array], { type: mimeType });
            }

            const keys = Object.keys(binaryData);
            if (keys.every((k) => /^\d+$/.test(k))) {
              const sortedKeys = keys.sort((a, b) => parseInt(a) - parseInt(b));
              bytes = sortedKeys.map((k) => {
                const val = binaryData[k];
                return typeof val === "number" && val >= 0 && val <= 255
                  ? Math.floor(val)
                  : 0;
              });

              if (bytes.length === 0) {
                throw new Error("No valid binary data found");
              }

              const uint8Array = new Uint8Array(bytes);

              if (bytes.length > 4) {
                mimeType = detectAudioFormat(bytes);
              }

              return new Blob([uint8Array], { type: mimeType });
            }

            throw new Error("Unrecognized binary data format");
          } catch (error) {
            console.error(
              "Error converting binary data to blob:",
              error,
              binaryData
            );
            return null;
          }
        }

        let settings = loadSettings();
        let responses = loadResponses();
        let retryCount = 0;

        let mediaRecorder = null;
        let recordedChunks = [];
        let recStart = 0;
        let recTimerInterval = null;
        let analyser = null;
        let audioContext = null;
        let isPaused = false;
        let pausedTime = 0;

        let practiceRecorder = null;
        let currentAudio = null;
        let currentPlayButton = null;
        let recordingAudio = null;

        const connDot = id("connDot");
        const connText = id("connText");
        const currentWebhook = id("currentWebhook");
        const modal = id("modal");
        const responsesEl = id("responses");
        const retryCountEl = id("retryCount");
        const sidebarResponses = id("sidebarResponses");
        const processingOverlay = id("processingOverlay");

        id("targetLang").addEventListener("change", function () {
          const customInput = id("customLangInput");
          if (this.value === "custom") {
            customInput.style.display = "block";
            customInput.focus();
          } else {
            customInput.style.display = "none";
            customInput.value = "";
          }
        });

        function reflectSettings() {
          id("settingWebhook").value = settings.webhook || "";
          id("settingApiKey").value = settings.apiKey || "";
          id("settingLangs").value = settings.langs || "";
          id("settingGeminiKey").value = settings.geminiKey || "";
          currentWebhook.textContent =
            settings.webhook || "(no webhook configured)";
          updateConnStatus("unknown");
        }

        function updateConnStatus(state, msg) {
          const states = {
            ok: { className: "connected", text: "Connected" },
            fail: { className: "error", text: "Failed" },
            unknown: { className: "", text: "Unknown" },
          };
          const s = states[state] || states.unknown;
          connDot.className = `status-dot ${s.className}`;
          connText.textContent = s.text;
          if (msg) connText.title = msg;
        }

        document.querySelectorAll(".tab").forEach((tab) => {
          tab.addEventListener("click", function () {
            document
              .querySelectorAll(".tab")
              .forEach((t) => t.classList.remove("active"));
            document
              .querySelectorAll(".tab-content")
              .forEach((c) => c.classList.remove("active"));

            this.classList.add("active");

            const tabName = this.getAttribute("data-tab");
            const content = document.getElementById(tabName + "-content");
            if (content) {
              content.classList.add("active");
            }
          });
        });

        async function pingWebhook() {
          if (!settings.webhook) {
            updateConnStatus("fail", "Webhook missing");
            return { ok: false, message: "no webhook" };
          }

          try {
            id("settingsPing").textContent = "Testing...";
            const headers = { "Content-Type": "application/json" };
            if (settings.apiKey) headers["x-api-key"] = settings.apiKey;

            const res = await fetch(settings.webhook, {
              method: "POST",
              headers,
              body: JSON.stringify({ ping: true }),
              mode: "cors",
            });

            const text = await res.text();
            id("settingsPing").textContent = res.ok
              ? "Connection OK"
              : `Error (${res.status})`;
            updateConnStatus(res.ok ? "ok" : "fail", text);
            return { ok: res.ok, status: res.status, text };
          } catch (e) {
            id("settingsPing").textContent = "Connection Failed";
            updateConnStatus("fail", e.message);
            return { ok: false, error: e };
          }
        }

        id("settingsBtn").addEventListener("click", () => {
          modal.classList.add("active");
        });

        id("closeSettings").addEventListener("click", () => {
          modal.classList.remove("active");
        });

        id("saveSettings").addEventListener("click", () => {
          settings.webhook = id("settingWebhook").value.trim();
          settings.apiKey = id("settingApiKey").value.trim();
          settings.langs = id("settingLangs").value.trim();
          settings.geminiKey = id("settingGeminiKey").value.trim();
          saveSettings(settings);
          reflectSettings();
          modal.classList.remove("active");
        });

        id("resetSettings").addEventListener("click", () => {
          localStorage.removeItem(SETTINGS_KEY);
          settings = loadSettings();
          reflectSettings();
        });

        id("settingsTest").addEventListener("click", () => {
          pingWebhook();
        });

        id("testConn").addEventListener("click", async () => {
          const result = await pingWebhook();
          if (result.ok) {
            alert("Connection successful!");
          } else {
            alert(
              "Connection failed. Check your settings and ensure CORS is configured on your webhook."
            );
          }
        });

        function renderSidebarResponses() {
          if (!responses.length) {
            sidebarResponses.innerHTML =
              '<div class="sidebar-empty">No responses yet</div>';
            return;
          }

          const recentResponses = responses.slice(-5).reverse();
          sidebarResponses.innerHTML = "";

          recentResponses.forEach((r, idx) => {
            const item = document.createElement("div");
            item.className = "sidebar-response";

            const isBinaryAudio = r.raw && isBinaryAudioData(r.raw);
            let previewContent = "";

            if (isBinaryAudio) {
              previewContent = "ðŸŽµ Audio Response";
            } else if (r.raw && typeof r.raw === "object") {
              if (r.raw.processedText) previewContent = r.raw.processedText;
              else if (r.raw.translatedText)
                previewContent = r.raw.translatedText;
              else if (r.raw.summary) previewContent = r.raw.summary;
              else if (r.raw.feedback) previewContent = r.raw.feedback;
              else if (r.raw.transcription)
                previewContent = r.raw.transcription;
              else if (r.raw.text) previewContent = r.raw.text;
              else if (r.raw.result) previewContent = r.raw.result;
              else previewContent = JSON.stringify(r.raw).substring(0, 100);
            } else if (typeof r.raw === "string") {
              previewContent = r.raw;
            } else {
              previewContent = "Response received";
            }

            item.innerHTML = `
                              <div class="sidebar-response-header">
                                  <span class="sidebar-response-type">${
                                    r.action || r.type || "response"
                                  }</span>
                                  <span class="sidebar-response-time">${new Date(
                                    r._ts || r.time
                                  ).toLocaleTimeString()}</span>
                              </div>
                              <div class="sidebar-response-content">${previewContent}</div>
                          `;

            item.addEventListener("click", () => {
              document
                .querySelectorAll(".tab")
                .forEach((t) => t.classList.remove("active"));
              document
                .querySelectorAll(".tab-content")
                .forEach((c) => c.classList.remove("active"));

              const responsesTab = document.querySelector(
                '.tab[data-tab="responses"]'
              );
              const responsesContent = id("responses-content");

              if (responsesTab) responsesTab.classList.add("active");
              if (responsesContent) responsesContent.classList.add("active");

              setTimeout(() => {
                const responseItems =
                  responsesEl.querySelectorAll(".response-item");
                const targetIndex =
                  responses.length -
                  1 -
                  (responses.length - 1 - responses.indexOf(r));
                if (responseItems[idx]) {
                  responseItems[idx].scrollIntoView({
                    behavior: "smooth",
                    block: "center",
                  });
                  responseItems[idx].style.border = "2px solid var(--primary)";
                  setTimeout(() => {
                    responseItems[idx].style.border = "";
                  }, 2000);
                }
              }, 100);
            });

            sidebarResponses.appendChild(item);
          });
        }

        function renderResponses() {
          if (!responses.length) {
            responsesEl.innerHTML =
              '<div class="text-muted text-sm">No responses yet. Send a request to see results here.</div>';
            return;
          }

          responsesEl.innerHTML = "";
          responses
            .slice()
            .reverse()
            .forEach((r, idx) => {
              const item = document.createElement("div");
              item.className = "response-item";

              const rawMode = id("rawToggle").checked || id("showRaw").checked;
              let content = "";
              let isBinaryAudio = false;

              if (r.raw && isBinaryAudioData(r.raw)) {
                isBinaryAudio = true;

                if (rawMode) {
                  if (r.raw.data && r.raw.mimeType) {
                    const dataInfo =
                      typeof r.raw.data === "string"
                        ? `Base64 string (${r.raw.data.length} chars)`
                        : Array.isArray(r.raw.data)
                        ? `Array (${r.raw.data.length} items)`
                        : r.raw.data.type === "Buffer"
                        ? `Buffer (${
                            Array.isArray(r.raw.data.data)
                              ? r.raw.data.data.length
                              : "unknown"
                          } bytes)`
                        : "Object with numeric keys";

                    content = `[n8n Binary Audio Data]\n\nMimeType: ${
                      r.raw.mimeType
                    }\nData Info: ${dataInfo}\n\nStructure Preview:\n${JSON.stringify(
                      {
                        mimeType: r.raw.mimeType,
                        dataType: typeof r.raw.data,
                        dataPreview:
                          typeof r.raw.data === "string"
                            ? r.raw.data.substring(0, 100) + "..."
                            : Array.isArray(r.raw.data)
                            ? r.raw.data.slice(0, 10)
                            : r.raw.data.type === "Buffer"
                            ? r.raw.data.data.slice(0, 10)
                            : "Complex object",
                      },
                      null,
                      2
                    )}`;
                  } else if (r.raw.type === "Buffer") {
                    content = `[Buffer Audio Data]\n\nType: ${
                      r.raw.type
                    }\nSize: ${
                      r.raw.data.length
                    } bytes\n\nFirst 20 bytes: [${r.raw.data
                      .slice(0, 20)
                      .join(", ")}...]`;
                  } else if (r.raw.binary) {
                    content = `[n8n Binary Object]\n\nBinary keys: ${Object.keys(
                      r.raw.binary
                    ).join(", ")}\n\nStructure: ${JSON.stringify(
                      r.raw,
                      null,
                      2
                    )}`;
                  } else {
                    const keys = Object.keys(r.raw);
                    content = `[Raw Binary Audio Data]\n\nTotal bytes: ${
                      keys.length
                    }\nData type: Numeric object with sequential keys\n\nFirst 20 bytes: [${keys
                      .slice(0, 20)
                      .map((k) => r.raw[k])
                      .join(", ")}...]`;
                  }
                } else {
                  let audioInfo = "";
                  let detectedFormat = "Unknown";
                  let audioSize = "Unknown";

                  if (r.raw.mimeType) {
                    detectedFormat = r.raw.mimeType;
                    audioInfo += `- Format: ${detectedFormat}\n`;
                  }

                  if (
                    r.raw.data &&
                    r.raw.data.data &&
                    Array.isArray(r.raw.data.data)
                  ) {
                    audioSize = `${r.raw.data.data.length} bytes`;
                    audioInfo += `- Size: ${audioSize}\n`;

                    const actualFormat = detectAudioFormat(
                      r.raw.data.data.slice(0, 12)
                    );
                    if (
                      actualFormat !== "audio/webm" &&
                      actualFormat !== detectedFormat
                    ) {
                      audioInfo += `- Detected Format: ${actualFormat}\n`;
                    }
                  } else if (r.raw.type === "Buffer" && r.raw.data) {
                    audioSize = `${r.raw.data.length} bytes`;
                    audioInfo += `- Size: ${audioSize}\n`;

                    const actualFormat = detectAudioFormat(
                      r.raw.data.slice(0, 12)
                    );
                    audioInfo += `- Detected Format: ${actualFormat}\n`;
                  } else if (typeof r.raw === "object") {
                    const keys = Object.keys(r.raw);
                    if (keys.every((k) => /^\d+$/.test(k))) {
                      audioSize = `${keys.length} bytes`;
                      audioInfo += `- Size: ${audioSize}\n`;

                      const byteArray = keys.slice(0, 12).map((k) => r.raw[k]);
                      const actualFormat = detectAudioFormat(byteArray);
                      audioInfo += `- Detected Format: ${actualFormat}\n`;
                    }
                  }

                  content = `ðŸŽµ Audio Response Received\n\n${audioInfo}\nThis binary audio data was sent from your n8n workflow.\n\nâœ¨ What you can do:\nâ€¢ Click "Play Audio" button below to listen\nâ€¢ Use "Download" to save the audio file\nâ€¢ Toggle "Raw JSON" to see technical details`;
                }
              } else if (rawMode) {
                try {
                  const rawCopy = { ...r.raw };
                  if (
                    rawCopy.audioBase64 &&
                    typeof rawCopy.audioBase64 === "string" &&
                    rawCopy.audioBase64.length > 100
                  ) {
                    rawCopy.audioBase64 = `[Base64 Audio Data - ${rawCopy.audioBase64.length} characters]`;
                  }
                  if (
                    rawCopy.audio &&
                    typeof rawCopy.audio === "string" &&
                    rawCopy.audio.length > 100
                  ) {
                    rawCopy.audio = `[Base64 Audio Data - ${rawCopy.audio.length} characters]`;
                  }
                  content = JSON.stringify(rawCopy, null, 2);
                } catch (e) {
                  content =
                    "[Could not parse response data]\n\n" + String(r.raw);
                }
              } else {
                const parts = [];

                if (r.raw && typeof r.raw === "object") {
                  if (r.raw.processedText)
                    parts.push("Processed Text:\n" + r.raw.processedText);
                  if (r.raw.translatedText)
                    parts.push("Translation:\n" + r.raw.translatedText);
                  if (r.raw.summary) parts.push("Summary:\n" + r.raw.summary);
                  if (r.raw.feedback)
                    parts.push("Feedback:\n" + r.raw.feedback);
                  if (r.raw.transcription)
                    parts.push("Transcription:\n" + r.raw.transcription);
                  if (r.raw.text) parts.push("Text:\n" + r.raw.text);
                  if (r.raw.result) parts.push("Result:\n" + r.raw.result);
                  if (r.raw.score !== undefined)
                    parts.push("Score: " + r.raw.score);

                  if (r.raw.audioBase64 || r.raw.audio) {
                    parts.push(
                      'ðŸŽµ Audio file received - use "Play Last Response" button to listen'
                    );
                  }

                  Object.keys(r.raw).forEach((key) => {
                    const excludeKeys = [
                      "processedText",
                      "translatedText",
                      "summary",
                      "feedback",
                      "transcription",
                      "text",
                      "result",
                      "score",
                      "audioBase64",
                      "audio",
                      "audioContentType",
                      "data",
                      "mimeType",
                      "type",
                    ];
                    if (!excludeKeys.includes(key) && !/^\d+$/.test(key)) {
                      const value = r.raw[key];
                      if (typeof value === "string" && value.length > 500) {
                        parts.push(
                          `${key}: [Large text - ${value.length} characters]`
                        );
                      } else if (value !== null && value !== undefined) {
                        parts.push(`${key}: ${JSON.stringify(value)}`);
                      }
                    }
                  });
                }

                if (!parts.length) {
                  if (typeof r.raw === "string") {
                    parts.push(r.raw);
                  } else {
                    parts.push(JSON.stringify(r.raw, null, 2));
                  }
                }
                content = parts.join("\n\n");
              }

              let responseHtml = `
                              <div class="response-header">
                                  <div class="response-meta">
                                      <span class="response-type">${
                                        r.action || r.type || "response"
                                      }</span>
                                      <span class="response-time">${new Date(
                                        r._ts || r.time
                                      ).toLocaleString()}</span>
                                  </div>
                                  <span class="response-status ${
                                    r.ok ? "success" : "error"
                                  }">
                                      ${r.ok ? "OK" : "Error"}
                                  </span>
                              </div>`;

              if (isBinaryAudio && !rawMode) {
                responseHtml += `
                              <div class="binary-audio-indicator">
                                  <i class="fas fa-music"></i>
                                  <div>
                                      <strong>Binary Audio File Detected</strong>
                                      <div class="text-sm">Audio data received from n8n - Click "Play Audio" to listen</div>
                                  </div>
                              </div>`;
              }

              responseHtml += `
                              <div class="response-content">${content}</div>
                              <div class="response-actions">
                                  <button class="btn btn-ghost copy-btn">
                                      <i class="fas fa-copy"></i> Copy
                                  </button>
                                  <button class="btn btn-ghost download-btn">
                                      <i class="fas fa-download"></i> Download
                                  </button>`;

              // Add speak button for text responses
              if (!isBinaryAudio) {
                let textToSpeak = "";
                if (r.raw && typeof r.raw === "object") {
                  textToSpeak =
                    r.raw.processedText ||
                    r.raw.translatedText ||
                    r.raw.summary ||
                    r.raw.feedback ||
                    r.raw.transcription ||
                    r.raw.text ||
                    r.raw.result ||
                    "";
                } else if (typeof r.raw === "string") {
                  textToSpeak = r.raw;
                }

                if (textToSpeak && textToSpeak.length > 0) {
                  responseHtml += `
          <button class="btn btn-ghost speak-btn" data-text="${textToSpeak
            .replace(/"/g, "&quot;")
            .replace(/'/g, "&#39;")}">
              <i class="fas fa-volume-up"></i> Speak
          </button>
          <button class="btn btn-ghost stop-speak-btn" style="display: none;">
              <i class="fas fa-stop"></i> Stop
          </button>`;
                }
              }

              if (isBinaryAudio) {
                responseHtml += `
              <button class="btn btn-ghost play-audio-btn" data-audio-id="response-${
                responses.length - 1 - idx
              }">
                  <i class="fas fa-play"></i> Play Audio
              </button>
              <button class="btn btn-ghost pause-audio-btn" data-audio-id="response-${
                responses.length - 1 - idx
              }" style="display: none;">
                  <i class="fas fa-pause"></i> Pause
              </button>
              <button class="btn btn-ghost resume-audio-btn" data-audio-id="response-${
                responses.length - 1 - idx
              }" style="display: none;">
                  <i class="fas fa-play"></i> Resume
              </button>
              <button class="btn btn-ghost replay-audio-btn" data-audio-id="response-${
                responses.length - 1 - idx
              }" style="display: none;">
                  <i class="fas fa-redo"></i> Replay
              </button>`;
              }

              responseHtml += `
                                  <button class="btn btn-ghost delete-btn" data-index="${
                                    responses.length - 1 - idx
                                  }">
                                      <i class="fas fa-trash"></i> Delete
                                  </button>
                              </div>
                          `;

              item.innerHTML = responseHtml;

              const copyBtn = item.querySelector(".copy-btn");
              const downloadBtn = item.querySelector(".download-btn");
              const deleteBtn = item.querySelector(".delete-btn");
              const playAudioBtn = item.querySelector(".play-audio-btn");

              copyBtn.addEventListener("click", () => {
                navigator.clipboard.writeText(content).then(() => {
                  copyBtn.innerHTML = '<i class="fas fa-check"></i> Copied!';
                  setTimeout(() => {
                    copyBtn.innerHTML = '<i class="fas fa-copy"></i> Copy';
                  }, 2000);
                });
              });

              downloadBtn.addEventListener("click", () => {
                if (isBinaryAudio) {
                  const audioBlob = convertBinaryDataToBlob(r.raw);
                  if (audioBlob) {
                    const url = URL.createObjectURL(audioBlob);
                    const a = document.createElement("a");
                    a.href = url;
                    a.download = `langassist-audio-${Date.now()}.webm`;
                    a.click();
                    URL.revokeObjectURL(url);
                  } else {
                    alert("Error converting audio data");
                  }
                } else {
                  const blob = new Blob([content], { type: "text/plain" });
                  const url = URL.createObjectURL(blob);
                  const a = document.createElement("a");
                  a.href = url;
                  a.download = `langassist-response-${Date.now()}.txt`;
                  a.click();
                  URL.revokeObjectURL(url);
                }
              });

              deleteBtn.addEventListener("click", () => {
                const index = parseInt(deleteBtn.dataset.index);
                responses.splice(index, 1);
                saveResponses(responses);
                renderResponses();
                renderSidebarResponses();
              });

              const speakBtn = item.querySelector(".speak-btn");
              const stopSpeakBtn = item.querySelector(".stop-speak-btn");

              if (speakBtn) {
                speakBtn.addEventListener("click", () => {
                  const text = speakBtn.dataset.text;
                  const langCode = detectLanguageCode(text);

                  console.log(
                    "Speaking text:",
                    text.substring(0, 50) + "...",
                    "Language:",
                    langCode
                  );

                  speakBtn.style.display = "none";
                  stopSpeakBtn.style.display = "";

                  speakText(text, langCode);

                  // Auto-hide stop button when speech ends
                  const utteranceCheck = setInterval(() => {
                    if (!window.speechSynthesis.speaking) {
                      clearInterval(utteranceCheck);
                      speakBtn.style.display = "";
                      stopSpeakBtn.style.display = "none";
                    }
                  }, 100);
                });
              }

              if (stopSpeakBtn) {
                stopSpeakBtn.addEventListener("click", () => {
                  window.speechSynthesis.cancel();
                  if (currentSpeechAudio) {
                    currentSpeechAudio.pause();
                    currentSpeechAudio = null;
                  }
                  speakBtn.style.display = "";
                  stopSpeakBtn.style.display = "none";
                });
              }

              if (playAudioBtn) {
                const pauseAudioBtn = item.querySelector(".pause-audio-btn");
                const resumeAudioBtn = item.querySelector(".resume-audio-btn");
                const replayAudioBtn = item.querySelector(".replay-audio-btn");

                playAudioBtn.addEventListener("click", () => {
                  playBinaryAudioWithControls(
                    r.raw,
                    playAudioBtn,
                    pauseAudioBtn,
                    resumeAudioBtn,
                    replayAudioBtn
                  );
                });

                if (pauseAudioBtn) {
                  pauseAudioBtn.addEventListener("click", () => {
                    pauseResponseAudio(
                      playAudioBtn,
                      pauseAudioBtn,
                      resumeAudioBtn,
                      replayAudioBtn
                    );
                  });
                }

                if (resumeAudioBtn) {
                  resumeAudioBtn.addEventListener("click", () => {
                    resumeResponseAudio(
                      playAudioBtn,
                      pauseAudioBtn,
                      resumeAudioBtn,
                      replayAudioBtn
                    );
                  });
                }

                if (replayAudioBtn) {
                  replayAudioBtn.addEventListener("click", () => {
                    replayResponseAudio(
                      r.raw,
                      playAudioBtn,
                      pauseAudioBtn,
                      resumeAudioBtn,
                      replayAudioBtn
                    );
                  });
                }
              }

              responsesEl.appendChild(item);
            });

          renderSidebarResponses();
        }

        async function playBinaryAudio(binaryData) {
          try {
            const audioBlob = convertBinaryDataToBlob(binaryData);
            if (!audioBlob) {
              alert("Error converting binary data to audio");
              return;
            }

            const url = URL.createObjectURL(audioBlob);
            const audio = new Audio(url);

            audio.onended = () => URL.revokeObjectURL(url);
            audio.onerror = () => {
              URL.revokeObjectURL(url);
              alert("Error playing audio. The format may not be supported.");
            };

            await audio.play();
          } catch (error) {
            alert("Error playing audio: " + error.message);
          }
        }

        async function playBinaryAudioWithControls(
          binaryData,
          playBtn,
          pauseBtn,
          resumeBtn,
          replayBtn
        ) {
          try {
            // Stop any currently playing audio
            if (currentAudio) {
              currentAudio.pause();
              currentAudio.currentTime = 0;
              if (currentPlayButton) {
                currentPlayButton.style.display = "";
                const parent = currentPlayButton.parentElement;
                const prevPauseBtn = parent.querySelector(".pause-audio-btn");
                const prevResumeBtn = parent.querySelector(".resume-audio-btn");
                const prevReplayBtn = parent.querySelector(".replay-audio-btn");
                if (prevPauseBtn) prevPauseBtn.style.display = "none";
                if (prevResumeBtn) prevResumeBtn.style.display = "none";
                if (prevReplayBtn) prevReplayBtn.style.display = "none";
              }
            }

            const audioBlob = convertBinaryDataToBlob(binaryData);
            if (!audioBlob) {
              alert("Error converting binary data to audio");
              return;
            }

            const url = URL.createObjectURL(audioBlob);
            const audio = new Audio(url);

            currentAudio = audio;
            currentPlayButton = playBtn;

            // Update UI
            playBtn.style.display = "none";
            pauseBtn.style.display = "";
            resumeBtn.style.display = "none";
            replayBtn.style.display = "none";

            audio.onended = () => {
              URL.revokeObjectURL(url);
              playBtn.style.display = "none";
              pauseBtn.style.display = "none";
              resumeBtn.style.display = "none";
              replayBtn.style.display = "";
              currentAudio = null;
              currentPlayButton = null;
            };

            audio.onerror = () => {
              URL.revokeObjectURL(url);
              alert("Error playing audio. The format may not be supported.");
              playBtn.style.display = "";
              pauseBtn.style.display = "none";
              resumeBtn.style.display = "none";
              replayBtn.style.display = "none";
              currentAudio = null;
              currentPlayButton = null;
            };

            await audio.play();
          } catch (error) {
            alert("Error playing audio: " + error.message);
            playBtn.style.display = "";
            pauseBtn.style.display = "none";
            resumeBtn.style.display = "none";
            replayBtn.style.display = "none";
            currentAudio = null;
            currentPlayButton = null;
          }
        }

        function pauseResponseAudio(playBtn, pauseBtn, resumeBtn, replayBtn) {
          if (currentAudio && !currentAudio.paused) {
            currentAudio.pause();
            playBtn.style.display = "none";
            pauseBtn.style.display = "none";
            resumeBtn.style.display = "";
            replayBtn.style.display = "";
          }
        }

        function resumeResponseAudio(playBtn, pauseBtn, resumeBtn, replayBtn) {
          if (
            currentAudio &&
            currentAudio.paused &&
            currentAudio.currentTime > 0
          ) {
            currentAudio.play();
            playBtn.style.display = "none";
            pauseBtn.style.display = "";
            resumeBtn.style.display = "none";
            replayBtn.style.display = "none";
          }
        }

        async function replayResponseAudio(
          binaryData,
          playBtn,
          pauseBtn,
          resumeBtn,
          replayBtn
        ) {
          if (currentAudio) {
            currentAudio.pause();
            currentAudio.currentTime = 0;
          }
          await playBinaryAudioWithControls(
            binaryData,
            playBtn,
            pauseBtn,
            resumeBtn,
            replayBtn
          );
        }

        id("playbackTTS").addEventListener("click", async () => {
          const audioResponse = responses
            .slice()
            .reverse()
            .find((r) => {
              if (!r.raw) return false;
              if (r.raw.audioBase64 || r.raw.audio) return true;
              if (isBinaryAudioData(r.raw)) return true;
              return false;
            });

          if (!audioResponse) {
            alert("No audio response found.");
            return;
          }

          try {
            // Stop any currently playing audio
            if (currentAudio) {
              currentAudio.pause();
              currentAudio.currentTime = 0;
              if (currentPlayButton) {
                currentPlayButton.style.display = "";
                currentPlayButton.innerHTML =
                  '<i class="fas fa-play"></i> Play Audio';
                const prevPauseBtn =
                  currentPlayButton.parentElement.querySelector(
                    ".pause-audio-btn"
                  );
                if (prevPauseBtn) prevPauseBtn.style.display = "none";
              }
            }

            let audioBlob;

            if (audioResponse.raw.audioBase64 || audioResponse.raw.audio) {
              const b64 =
                audioResponse.raw.audioBase64 || audioResponse.raw.audio;
              const contentType =
                audioResponse.raw.audioContentType || "audio/mpeg";
              audioBlob = base64ToBlob(b64, contentType);
            } else if (isBinaryAudioData(audioResponse.raw)) {
              audioBlob = convertBinaryDataToBlob(audioResponse.raw);
            }

            if (audioBlob) {
              const url = URL.createObjectURL(audioBlob);
              const audio = new Audio(url);

              audio.onended = () => URL.revokeObjectURL(url);
              audio.onerror = () => {
                URL.revokeObjectURL(url);
                alert("Error playing audio. The format may not be supported.");
              };

              await audio.play();
            }
          } catch (error) {
            alert("Error playing audio: " + error.message);
          }
        });

        id("clearResponses").addEventListener("click", () => {
          responses = [];
          saveResponses(responses);
          renderResponses();
          renderSidebarResponses();
        });

        id("downloadAll").addEventListener("click", () => {
          const blob = new Blob([JSON.stringify(responses, null, 2)], {
            type: "application/json",
          });
          const url = URL.createObjectURL(blob);
          const a = document.createElement("a");
          a.href = url;
          a.download = "langassist-responses.json";
          a.click();
          URL.revokeObjectURL(url);
        });

        async function sendToWebhook(payload, meta = {}) {
          if (!settings.webhook) {
            alert("No webhook configured. Please open Settings and add one.");
            return;
          }

          const section = getCurrentSection();
          const enhancedPayload = {
            ...payload,
            section: section,
          };

          const headers = {};
          if (settings.apiKey) headers["x-api-key"] = settings.apiKey;

          try {
            let res, raw;
            const useMultipart =
              id("useMultipart") && id("useMultipart").checked;

            if (useMultipart && meta.formData) {
              meta.formData.append("section", section);
              res = await fetch(settings.webhook, {
                method: "POST",
                headers: { ...headers },
                body: meta.formData,
              });
              raw = await tryParseResponse(res);
            } else if (useMultipart && meta.blob) {
              const fd = new FormData();
              fd.append("file", meta.blob, meta.filename || "recording.webm");
              fd.append("payload", JSON.stringify(enhancedPayload));
              fd.append("section", section);
              res = await fetch(settings.webhook, {
                method: "POST",
                headers: { ...headers },
                body: fd,
              });
              raw = await tryParseResponse(res);
            } else {
              const body = { ...enhancedPayload };
              if (meta.blob) {
                const b64 = await blobToBase64(meta.blob);
                body.file = {
                  filename: meta.filename || "recording.webm",
                  contentType: meta.blob.type || "application/octet-stream",
                  base64: b64,
                };
              }
              res = await fetch(settings.webhook, {
                method: "POST",
                headers: { ...headers, "Content-Type": "application/json" },
                body: JSON.stringify(body),
              });
              raw = await tryParseResponse(res);
            }

            const entry = {
              ok: res.ok,
              status: res.status,
              raw,
              action: meta.action || payload.action || "unknown",
              time: Date.now(),
              type: meta.type || "request",
              _ts: Date.now(),
            };

            responses.push(entry);
            saveResponses(responses);
            renderResponses();

            if (!res.ok) {
              retryCount++;
              retryCountEl.textContent = retryCount;
            }
          } catch (err) {
            const entry = {
              ok: false,
              status: "network",
              raw: String(err),
              action: meta.action || payload.action,
              time: Date.now(),
              _ts: Date.now(),
            };
            responses.push(entry);
            saveResponses(responses);
            renderResponses();
            retryCount++;
            retryCountEl.textContent = retryCount;
          }
        }

        async function tryParseResponse(res) {
          const ct = res.headers.get("content-type") || "";
          try {
            if (ct.includes("application/json")) return await res.json();
            return await res.text();
          } catch (e) {
            try {
              return await res.text();
            } catch (e2) {
              return null;
            }
          }
        }

        function buildPayload(base) {
          return {
            ...base,
            meta: {
              app: "LangAssist",
              version: "1.1",
              timestamp: Date.now(),
            },
          };
        }

        async function submitText() {
          let targetLang = id("targetLang").value;

          if (targetLang === "custom") {
            const customLang = id("customLangInput").value.trim();
            if (!customLang) {
              alert(
                "Please enter a custom language or select from the dropdown."
              );
              id("customLangInput").focus();
              return;
            }
            targetLang = customLang;
          }

          const payload = buildPayload({
            action: id("action").value,
            tone: id("tone").value,
            inputLang: id("inputLang").value,
            targetLang: targetLang,
            userId: id("userId").value || null,
            text: id("textToProcess").value,
          });
          await sendToWebhook(payload, {
            type: "text",
            action: payload.action,
          });
        }

        id("sendText").addEventListener("click", submitText);
        id("clearText").addEventListener("click", () => {
          id("textToProcess").value = "";
        });

        id("textToProcess").addEventListener("keydown", (e) => {
          if (e.key === "Enter" && (e.ctrlKey || e.metaKey)) {
            e.preventDefault();
            submitText();
          }
        });

        async function startRecording() {
          if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
            alert("Media recording not supported in this browser");
            return;
          }

          try {
            const stream = await navigator.mediaDevices.getUserMedia({
              audio: true,
            });
            audioContext = new (window.AudioContext ||
              window.webkitAudioContext)();
            const source = audioContext.createMediaStreamSource(stream);
            analyser = audioContext.createAnalyser();
            analyser.fftSize = 256;
            source.connect(analyser);

            recordedChunks = [];
            const format = id("recordFormat").value || "webm";
            const mimeType =
              format === "wav"
                ? "audio/wav"
                : format === "ogg"
                ? "audio/ogg"
                : "audio/webm";

            mediaRecorder = new MediaRecorder(stream, { mimeType });
            mediaRecorder.ondataavailable = (e) => {
              if (e.data && e.data.size) recordedChunks.push(e.data);
            };

            mediaRecorder.onstop = async () => {
              const blob = new Blob(recordedChunks, {
                type: recordedChunks[0] ? recordedChunks[0].type : mimeType,
              });
              id("playRec").disabled = false;
              id("downloadRec").disabled = false;

              window._lastRecording = {
                blob,
                filename: "recording." + format,
                ext: format,
              };

              stream.getTracks().forEach((track) => track.stop());
            };

            mediaRecorder.start(250);
            recStart = Date.now();
            isPaused = false;
            pausedTime = 0;
            recTimerInterval = setInterval(updateTimer, 200);
            updateMeter();

            id("recBtn").disabled = true;
            id("pauseRec").disabled = false;
            id("stopRec").disabled = false;
          } catch (e) {
            alert("Could not start recording: " + e.message);
          }
        }

        function updateTimer() {
          if (!isPaused) {
            const elapsed = Math.floor(
              (Date.now() - recStart - pausedTime) / 1000
            );
            const mm = String(Math.floor(elapsed / 60)).padStart(2, "0");
            const ss = String(elapsed % 60).padStart(2, "0");
            id("recTimer").textContent = `${mm}:${ss}`;
          }
        }

        function updateMeter() {
          if (!analyser) return;
          const data = new Uint8Array(analyser.frequencyBinCount);
          analyser.getByteFrequencyData(data);
          const rms = Math.sqrt(
            data.reduce((s, v) => s + v * v, 0) / data.length
          );
          const pct = Math.min(100, Math.round(rms));
          id("meterFill").style.width = pct + "%";
          if (mediaRecorder && mediaRecorder.state === "recording") {
            requestAnimationFrame(updateMeter);
          }
        }

        function pauseRecording() {
          if (mediaRecorder && mediaRecorder.state === "recording") {
            mediaRecorder.pause();
            isPaused = true;
            const pauseBtn = id("pauseRec");
            pauseBtn.innerHTML = '<i class="fas fa-play"></i> Resume';
            pauseBtn.classList.remove("btn-warning");
            pauseBtn.classList.add("btn-success");
            window._pauseStartTime = Date.now();
          }
        }

        function resumeRecording() {
          if (mediaRecorder && mediaRecorder.state === "paused") {
            mediaRecorder.resume();
            isPaused = false;
            const pauseBtn = id("pauseRec");
            pauseBtn.innerHTML = '<i class="fas fa-pause"></i> Pause';
            pauseBtn.classList.remove("btn-success");
            pauseBtn.classList.add("btn-warning");
            if (window._pauseStartTime) {
              pausedTime += Date.now() - window._pauseStartTime;
            }
            updateMeter();
          }
        }

        function stopRecording() {
          if (
            mediaRecorder &&
            (mediaRecorder.state === "recording" ||
              mediaRecorder.state === "paused")
          ) {
            mediaRecorder.stop();
          }

          // Reset all recording buttons
          id("recBtn").disabled = false;
          id("pauseRec").disabled = true;
          id("stopRec").disabled = true;

          const pauseBtn = id("pauseRec");
          pauseBtn.innerHTML = '<i class="fas fa-pause"></i> Pause';
          pauseBtn.classList.remove("btn-success");
          pauseBtn.classList.add("btn-warning");

          // Reset playback buttons
          id("playRec").disabled = false;
          id("playRec").style.display = "";
          id("pauseRecBtn").style.display = "none";
          id("pauseRecBtn").disabled = true;
          id("resumeRecBtn").style.display = "none";
          id("resumeRecBtn").disabled = true;

          isPaused = false;
          pausedTime = 0;
          clearInterval(recTimerInterval);
          id("meterFill").style.width = "0%";

          // Stop any playing recording audio
          if (recordingAudio) {
            recordingAudio.pause();
            recordingAudio = null;
          }
        }

        function playRecording() {
          const rec = window._lastRecording;
          if (!rec) {
            alert("No recording available");
            return;
          }

          // Stop any currently playing audio
          if (recordingAudio) {
            recordingAudio.pause();
            recordingAudio.currentTime = 0;
          }

          const url = URL.createObjectURL(rec.blob);
          const audio = new Audio(url);
          recordingAudio = audio;

          const playBtn = id("playRec");
          const pauseBtn = id("pauseRecBtn");
          const resumeBtn = id("resumeRecBtn");

          playBtn.style.display = "none";
          pauseBtn.style.display = "";
          pauseBtn.disabled = false;
          resumeBtn.style.display = "none";

          audio.onended = () => {
            URL.revokeObjectURL(url);
            playBtn.style.display = "";
            pauseBtn.style.display = "none";
            resumeBtn.style.display = "none";
            recordingAudio = null;
          };

          audio.onerror = () => {
            URL.revokeObjectURL(url);
            alert("Error playing audio");
            playBtn.style.display = "";
            pauseBtn.style.display = "none";
            resumeBtn.style.display = "none";
            recordingAudio = null;
          };

          audio.play();
        }

        function downloadRecording() {
          const rec = window._lastRecording;
          if (!rec) {
            alert("No recording available");
            return;
          }
          const url = URL.createObjectURL(rec.blob);
          const a = document.createElement("a");
          a.href = url;
          a.download = rec.filename;
          a.click();
          URL.revokeObjectURL(url);
        }

        id("recBtn").addEventListener("click", startRecording);
        id("pauseRec").addEventListener("click", () => {
          if (mediaRecorder) {
            if (mediaRecorder.state === "recording") {
              pauseRecording();
            } else if (mediaRecorder.state === "paused") {
              resumeRecording();
            }
          }
        });
        id("stopRec").addEventListener("click", stopRecording);
        id("playRec").addEventListener("click", playRecording);
        id("playRec").addEventListener("click", playRecording);

        id("pauseRecBtn").addEventListener("click", () => {
          if (recordingAudio && !recordingAudio.paused) {
            recordingAudio.pause();
            const playBtn = id("playRec");
            const pauseBtn = id("pauseRecBtn");
            const resumeBtn = id("resumeRecBtn");

            playBtn.style.display = "none";
            pauseBtn.style.display = "none";
            resumeBtn.style.display = "";
            resumeBtn.disabled = false;
          }
        });

        id("resumeRecBtn").addEventListener("click", () => {
          if (recordingAudio && recordingAudio.paused) {
            recordingAudio.play();
            const playBtn = id("playRec");
            const pauseBtn = id("pauseRecBtn");
            const resumeBtn = id("resumeRecBtn");

            playBtn.style.display = "none";
            pauseBtn.style.display = "";
            resumeBtn.style.display = "none";
          }
        });
        id("downloadRec").addEventListener("click", downloadRecording);

        id("audioFile").addEventListener("change", (e) => {
          const f = e.target.files[0];
          if (!f) return;
          if (f.size > 10 * 1024 * 1024) {
            alert("File too large (max 10MB)");
            id("audioFile").value = "";
            return;
          }
        });

        id("sendAudio").addEventListener("click", async () => {
          const f = id("audioFile").files[0];
          const useMultipart = id("useMultipart") && id("useMultipart").checked;

          if (f) {
            if (f.size > 10 * 1024 * 1024) {
              alert("File too large (10MB max)");
              return;
            }

            if (useMultipart) {
              const fd = new FormData();
              fd.append("file", f, f.name);
              fd.append(
                "payload",
                JSON.stringify({
                  action: "transcribe",
                  type: "upload",
                  timestamp: Date.now(),
                })
              );
              await sendToWebhook(
                {},
                { formData: fd, action: "upload", type: "audio" }
              );
            } else {
              await sendToWebhook(
                { action: "transcribe", type: "upload", timestamp: Date.now() },
                { blob: f, filename: f.name, action: "upload", type: "audio" }
              );
            }
          } else if (window._lastRecording && window._lastRecording.blob) {
            const rec = window._lastRecording;
            if (useMultipart) {
              const fd = new FormData();
              fd.append("file", rec.blob, rec.filename);
              fd.append(
                "payload",
                JSON.stringify({
                  action: "transcribe",
                  type: "recording",
                  timestamp: Date.now(),
                })
              );
              await sendToWebhook(
                {},
                { formData: fd, action: "recording", type: "audio" }
              );
            } else {
              await sendToWebhook(
                {
                  action: "transcribe",
                  type: "recording",
                  timestamp: Date.now(),
                },
                {
                  blob: rec.blob,
                  filename: rec.filename,
                  action: "recording",
                  type: "audio",
                }
              );
            }
          } else {
            alert("No audio file selected or recorded.");
          }
        });

        // Practice Mode Toggle
        id("practiceMode").addEventListener("change", function () {
          const customSection = id("customTextSection");
          const ttSection = id("tongueTwisterSection");

          if (this.value === "custom") {
            customSection.style.display = "block";
            ttSection.style.display = "none";
            id("generatedTTContainer").style.display = "none";
          } else {
            customSection.style.display = "none";
            ttSection.style.display = "block";
          }
        });

        // Generate Tongue Twister
        async function generateTongueTwister() {
          if (!settings.geminiKey) {
            alert(
              "Please configure your Gemini API key in Settings to use the Tongue Twister Generator."
            );
            return;
          }

          const language = id("ttLanguage").value;
          const level = id("ttLevel").value;
          const generateBtn = id("generateTT");

          generateBtn.disabled = true;
          generateBtn.innerHTML =
            '<i class="fas fa-spinner fa-spin"></i> Generating...';

          try {
            const prompt = `Generate a ${level} difficulty tongue twister in ${language}.

Requirements:
- ${level === "easy" ? "Simple words, 1 sentence, clear pronunciation" : ""}
${
  level === "medium"
    ? "Moderate complexity, 1-2 sentences, some challenging sounds"
    : ""
}
${level === "hard" ? "Complex sounds, 2-3 sentences, rapid repetition" : ""}
${
  level === "expert"
    ? "Very challenging, 3+ sentences, complex phonetic patterns"
    : ""
}
- Should be fun and engaging
- Focus on pronunciation practice
- Return ONLY the tongue twister text, nothing else`;

            console.log("Making request to Gemini API...");

            const response = await fetch(
              `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent?key=${settings.geminiKey}`,
              {
                method: "POST",
                headers: {
                  "Content-Type": "application/json",
                },
                body: JSON.stringify({
                  contents: [
                    {
                      role: "user",
                      parts: [{ text: prompt }],
                    },
                  ],
                }),
              }
            );

            console.log("Response status:", response.status);

            if (!response.ok) {
              const errorText = await response.text();
              console.error("API Error Response:", errorText);
              let errorData;
              try {
                errorData = JSON.parse(errorText);
              } catch (e) {
                errorData = { message: errorText };
              }
              throw new Error(
                `Gemini API error: ${response.status} - ${
                  errorData.error?.message || errorText
                }`
              );
            }

            const data = await response.json();
            console.log("API Response:", data);

            // More robust response parsing
            let tongueTwister = "";

            if (
              data.candidates &&
              Array.isArray(data.candidates) &&
              data.candidates.length > 0
            ) {
              const candidate = data.candidates[0];
              if (
                candidate.content &&
                candidate.content.parts &&
                Array.isArray(candidate.content.parts) &&
                candidate.content.parts.length > 0
              ) {
                tongueTwister = candidate.content.parts[0].text?.trim() || "";
              }
            }

            if (!tongueTwister) {
              console.error("Unexpected API response structure:", data);
              throw new Error(
                "Invalid response structure from Gemini API. The API returned data but in an unexpected format."
              );
            }

            id("generatedTT").textContent = tongueTwister;
            id("generatedTTContainer").style.display = "block";
            id("practiceText").value = tongueTwister;

            generateBtn.disabled = false;
            generateBtn.innerHTML =
              '<i class="fas fa-magic"></i> Generate Tongue Twister';
          } catch (error) {
            console.error("Full error:", error);
            alert(
              `Failed to generate tongue twister.\n\nError: ${error.message}\n\nPlease check:\n1. Your Gemini API key is valid\n2. You have API quota remaining\n3. Browser console (F12) for more details`
            );
            generateBtn.disabled = false;
            generateBtn.innerHTML =
              '<i class="fas fa-magic"></i> Generate Tongue Twister';
          }
        }

        id("generateTT").addEventListener("click", generateTongueTwister);
        id("regenerateTT").addEventListener("click", generateTongueTwister);

        // Start Practice
        id("startPractice").addEventListener("click", async () => {
          const practiceMode = id("practiceMode").value;
          let practiceText = "";

          if (practiceMode === "custom") {
            practiceText = id("practiceText").value.trim();
          } else {
            practiceText = id("generatedTT").textContent.trim();
          }

          if (!practiceText) {
            alert(
              practiceMode === "custom"
                ? "Please enter text to practice"
                : "Please generate a tongue twister first"
            );
            return;
          }

          id("startPractice").disabled = true;
          id("stopPractice").disabled = false;

          if (!navigator.mediaDevices) {
            alert("Media recording not supported");
            id("startPractice").disabled = false;
            id("stopPractice").disabled = true;
            return;
          }

          try {
            const stream = await navigator.mediaDevices.getUserMedia({
              audio: true,
            });
            practiceRecorder = new MediaRecorder(stream);
            const chunks = [];

            practiceRecorder.ondataavailable = (e) => {
              if (e.data && e.data.size) chunks.push(e.data);
            };

            practiceRecorder.onstop = async () => {
              id("startPractice").disabled = true;
              id("stopPractice").disabled = true;

              processingOverlay.classList.add("active");

              const blob = new Blob(chunks, {
                type: chunks[0] ? chunks[0].type : "audio/webm",
              });

              await sendToWebhook(
                {
                  action: "pronunciation_score",
                  text: practiceText,
                  practiceMode: practiceMode,
                  level:
                    practiceMode === "tonguetwister"
                      ? id("ttLevel").value
                      : null,
                  language:
                    practiceMode === "tonguetwister"
                      ? id("ttLanguage").value
                      : null,
                  timestamp: Date.now(),
                },
                { blob, filename: "practice.webm", action: "practice" }
              );

              processingOverlay.classList.remove("active");

              id("startPractice").disabled = false;
              id("stopPractice").disabled = true;
              stream.getTracks().forEach((track) => track.stop());

              id("startPractice").innerHTML =
                '<i class="fas fa-microphone"></i> Start Practice';
            };

            practiceRecorder.start();

            id("startPractice").innerHTML =
              '<i class="fas fa-circle" style="color: red; animation: pulse 1s infinite;"></i> Recording...';
          } catch (e) {
            alert("Could not start practice recording: " + e.message);
            id("startPractice").disabled = false;
            id("stopPractice").disabled = true;
            id("startPractice").innerHTML =
              '<i class="fas fa-microphone"></i> Start Practice';
          }
        });

        // Stop Practice
        id("stopPractice").addEventListener("click", () => {
          if (practiceRecorder && practiceRecorder.state === "recording") {
            practiceRecorder.stop();
            id("stopPractice").innerHTML =
              '<i class="fas fa-spinner fa-spin"></i> Processing...';
          }
        });

        function blobToBase64(blob) {
          return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = () => resolve(reader.result.split(",")[1]);
            reader.onerror = reject;
            reader.readAsDataURL(blob);
          });
        }

        function base64ToBlob(b64, mimeType) {
          const byteCharacters = atob(b64);
          const byteNumbers = new Array(byteCharacters.length);
          for (let i = 0; i < byteCharacters.length; i++) {
            byteNumbers[i] = byteCharacters.charCodeAt(i);
          }
          const byteArray = new Uint8Array(byteNumbers);
          return new Blob([byteArray], { type: mimeType });
        }

        // Global variable to track current audio
        let currentSpeechAudio = null;

        function speakText(text, languageCode = "en-US") {
          window.speechSynthesis.cancel();

          // Small delay to ensure voices are loaded
          setTimeout(() => {
            const utterance = new SpeechSynthesisUtterance(text);
            utterance.lang = languageCode;
            utterance.rate = 0.85;
            utterance.pitch = 1;
            utterance.volume = 1;

            const voices = window.speechSynthesis.getVoices();
            const langPrefix = languageCode.split("-")[0];

            // Find best matching voice
            let voice =
              voices.find((v) => v.lang === languageCode) ||
              voices.find((v) => v.lang.startsWith(langPrefix)) ||
              voices.find((v) => v.name.toLowerCase().includes(langPrefix));

            if (voice) {
              utterance.voice = voice;
            } else if (langPrefix === "kn") {
              // Show one-time instruction for Kannada
              if (!localStorage.getItem("kannada_tts_shown")) {
                alert(
                  "For Kannada text-to-speech:\n\nðŸ“± Android: Settings â†’ System â†’ Languages & input â†’ Text-to-speech â†’ Install Google TTS\n\nðŸ’» Windows: Settings â†’ Time & Language â†’ Speech â†’ Add Indian languages\n\nðŸŒ Chrome: Best support with Google voices"
                );
                localStorage.setItem("kannada_tts_shown", "true");
              }
            }

            window.speechSynthesis.speak(utterance);
          }, 100);
        }

        function detectLanguageCode(text) {
          if (/[\u0C80-\u0CFF]/.test(text)) return "kn-IN";
          if (/[\u0C00-\u0C7F]/.test(text)) return "te-IN";
          if (/[\u0B80-\u0BFF]/.test(text)) return "ta-IN";
          if (/[\u0D00-\u0D7F]/.test(text)) return "ml-IN";
          if (/[\u0900-\u097F]/.test(text)) return "hi-IN";
          if (/[Ã¡Ã©Ã­Ã³ÃºÃ±Ã¼]/i.test(text)) return "es-ES";
          if (/[Ã Ã¢Ã¤Ã©Ã¨ÃªÃ«Ã¯Ã®Ã´Ã¹Ã»Ã¼Ã¿Ã¦Å“Ã§]/i.test(text)) return "fr-FR";
          if (/[Ã¤Ã¶Ã¼ÃŸ]/i.test(text)) return "de-DE";
          if (/[\u4E00-\u9FFF]/.test(text)) return "zh-CN";
          if (/[\u3040-\u309F\u30A0-\u30FF]/.test(text)) return "ja-JP";
          if (/[\uAC00-\uD7AF]/.test(text)) return "ko-KR";
          if (/[\u0400-\u04FF]/.test(text)) return "ru-RU";
          return "en-US";
        }

        id("rawToggle").addEventListener("change", renderResponses);
        id("showRaw").addEventListener("change", renderResponses);

        modal.addEventListener("click", (e) => {
          if (e.target === modal) {
            modal.classList.remove("active");
          }
        });

        document.addEventListener("keydown", (e) => {
          if (e.key === "Escape" && modal.classList.contains("active")) {
            modal.classList.remove("active");
          }
        });

        reflectSettings();
        renderResponses();
        renderSidebarResponses();
        retryCountEl.textContent = retryCount;

        setTimeout(() => {
          pingWebhook();
        }, 1000);

        // Initialize speech synthesis voices
        if ("speechSynthesis" in window) {
          // Force load voices immediately
          window.speechSynthesis.getVoices();

          // Chrome loads voices asynchronously
          window.speechSynthesis.onvoiceschanged = () => {
            const voices = window.speechSynthesis.getVoices();
            console.log("Voices loaded:", voices.length);
            console.log(
              "Kannada voices:",
              voices.filter(
                (v) =>
                  v.lang.includes("kn") ||
                  v.name.toLowerCase().includes("kannada")
              )
            );
          };

          // Trigger voice loading
          setTimeout(() => {
            window.speechSynthesis.getVoices();
          }, 100);
        }

        window.langassist = {
          sendToWebhook,
          settings,
          saveSettings,
          loadSettings,
          responses,
          saveResponses,
          isBinaryAudioData,
          convertBinaryDataToBlob,
          playBinaryAudio,
          detectAudioFormat,
          getCurrentSection,
        };
      })();
    </script>
  </body>
</html>
