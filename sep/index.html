<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LangAssist - AI Language Learning Assistant</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <style>
        :root {
            --primary: #2563eb;
            --primary-dark: #1d4ed8;
            --success: #10b981;
            --error: #ef4444;
            --warning: #f59e0b;
            --bg: #f8fafc;
            --card: #ffffff;
            --border: #e2e8f0;
            --text: #1e293b;
            --text-muted: #64748b;
            --shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px 0 rgba(0, 0, 0, 0.06);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--bg);
            color: var(--text);
            line-height: 1.6;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            background: var(--card);
            padding: 20px;
            border-radius: 12px;
            box-shadow: var(--shadow);
            margin-bottom: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 15px;
        }

        .header h1 {
            color: var(--primary);
            font-size: 1.8rem;
            font-weight: 700;
        }

        .header-controls {
            display: flex;
            gap: 15px;
            align-items: center;
            flex-wrap: wrap;
        }

        .status-indicator {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.9rem;
        }

        .status-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: var(--text-muted);
        }

        .status-dot.connected {
            background: var(--success);
        }

        .status-dot.error {
            background: var(--error);
        }

        .btn {
            padding: 8px 16px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9rem;
            font-weight: 500;
            transition: all 0.2s;
            display: inline-flex;
            align-items: center;
            gap: 6px;
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .btn-primary {
            background: var(--primary);
            color: white;
        }

        .btn-primary:hover:not(:disabled) {
            background: var(--primary-dark);
        }

        .btn-secondary {
            background: var(--border);
            color: var(--text);
        }

        .btn-secondary:hover:not(:disabled) {
            background: #cbd5e1;
        }

        .btn-ghost {
            background: transparent;
            color: var(--text-muted);
            border: 1px solid var(--border);
        }

        .btn-ghost:hover:not(:disabled) {
            background: var(--bg);
            color: var(--text);
        }

        .btn-success {
            background: var(--success);
            color: white;
        }

        .btn-danger {
            background: var(--error);
            color: white;
        }

        .tabs {
            background: var(--card);
            border-radius: 12px;
            box-shadow: var(--shadow);
            overflow: hidden;
            margin-bottom: 20px;
        }

        .tab-header {
            display: flex;
            background: var(--bg);
            border-bottom: 1px solid var(--border);
        }

        .tab {
            padding: 15px 20px;
            cursor: pointer;
            border: none;
            background: none;
            color: var(--text-muted);
            font-size: 0.9rem;
            font-weight: 500;
            transition: all 0.2s;
            border-bottom: 2px solid transparent;
        }

        .tab.active {
            color: var(--primary);
            border-bottom-color: var(--primary);
            background: var(--card);
        }

        .tab:hover:not(.active) {
            color: var(--text);
        }

        .tab-content {
            display: none;
            padding: 20px;
        }

        .tab-content.active {
            display: block;
        }

        .form-group {
            margin-bottom: 20px;
        }

        .form-group label {
            display: block;
            margin-bottom: 6px;
            font-weight: 500;
            color: var(--text);
        }

        .form-control {
            width: 100%;
            padding: 10px 12px;
            border: 1px solid var(--border);
            border-radius: 6px;
            font-size: 0.9rem;
            transition: border-color 0.2s;
        }

        .form-control:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.1);
        }

        select.form-control {
            cursor: pointer;
        }

        textarea.form-control {
            resize: vertical;
            min-height: 100px;
        }

        .form-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
        }

        @media (max-width: 768px) {
            .form-row {
                grid-template-columns: 1fr;
            }
        }

        .recording-section {
            background: var(--bg);
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
        }

        .recording-controls {
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap;
            margin-bottom: 15px;
        }

        .recording-timer {
            font-family: 'Courier New', monospace;
            font-size: 1.2rem;
            font-weight: bold;
            color: var(--primary);
            margin-left: 10px;
        }

        .audio-meter {
            flex: 1;
            height: 8px;
            background: var(--border);
            border-radius: 4px;
            overflow: hidden;
            margin: 0 15px;
        }

        .audio-meter-fill {
            height: 100%;
            background: var(--success);
            width: 0%;
            transition: width 0.1s;
        }

        .responses-section {
            background: var(--card);
            border-radius: 12px;
            box-shadow: var(--shadow);
            padding: 20px;
        }

        .responses-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            flex-wrap: wrap;
            gap: 15px;
        }

        .responses-header h2 {
            font-size: 1.3rem;
            font-weight: 600;
        }

        .responses-controls {
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap;
        }

        .response-item {
            border: 1px solid var(--border);
            border-radius: 8px;
            margin-bottom: 15px;
            overflow: hidden;
            background: var(--card);
        }

        .response-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 15px;
            background: var(--bg);
            border-bottom: 1px solid var(--border);
        }

        .response-meta {
            display: flex;
            gap: 15px;
            align-items: center;
        }

        .response-type {
            background: var(--primary);
            color: white;
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 0.8rem;
            font-weight: 500;
        }

        .response-time {
            color: var(--text-muted);
            font-size: 0.8rem;
        }

        .response-status {
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.8rem;
            font-weight: 500;
        }

        .response-status.success {
            background: rgba(16, 185, 129, 0.1);
            color: var(--success);
        }

        .response-status.error {
            background: rgba(239, 68, 68, 0.1);
            color: var(--error);
        }

        .response-content {
            padding: 15px;
            white-space: pre-wrap;
            font-family: 'Monaco', 'Courier New', monospace;
            font-size: 0.9rem;
            line-height: 1.5;
            background: #f9fafb;
            max-height: 300px;
            overflow-y: auto;
        }

        .response-actions {
            padding: 12px 15px;
            background: var(--bg);
            border-top: 1px solid var(--border);
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        .binary-audio-indicator {
            padding: 15px;
            background: linear-gradient(135deg, rgba(37, 99, 235, 0.05), rgba(16, 185, 129, 0.05));
            border-left: 4px solid var(--primary);
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .binary-audio-indicator i {
            font-size: 1.5rem;
            color: var(--primary);
        }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 1000;
            backdrop-filter: blur(4px);
        }

        .modal.active {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        .modal-content {
            background: var(--card);
            border-radius: 12px;
            max-width: 600px;
            width: 100%;
            max-height: 90vh;
            overflow-y: auto;
        }

        .modal-header {
            padding: 20px;
            border-bottom: 1px solid var(--border);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .modal-header h2 {
            margin: 0;
            font-size: 1.3rem;
        }

        .close-btn {
            background: none;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            color: var(--text-muted);
            padding: 5px;
        }

        .modal-body {
            padding: 20px;
        }

        .modal-footer {
            padding: 20px;
            border-top: 1px solid var(--border);
            display: flex;
            gap: 10px;
            justify-content: flex-end;
        }

        .checkbox {
            display: flex;
            align-items: center;
            gap: 8px;
            margin: 10px 0;
        }

        .checkbox input[type="checkbox"] {
            width: 16px;
            height: 16px;
            accent-color: var(--primary);
        }

        .file-input-wrapper {
            position: relative;
            display: inline-block;
            cursor: pointer;
        }

        .file-input-wrapper input[type="file"] {
            position: absolute;
            opacity: 0;
            width: 100%;
            height: 100%;
            cursor: pointer;
        }

        .text-muted {
            color: var(--text-muted);
        }

        .text-sm {
            font-size: 0.8rem;
        }

        .webhook-display {
            font-family: monospace;
            background: var(--bg);
            padding: 8px 12px;
            border-radius: 4px;
            border: 1px solid var(--border);
            word-break: break-all;
            font-size: 0.85rem;
        }

        @keyframes pulse {
            0% {
                opacity: 1;
            }

            50% {
                opacity: 0.5;
            }

            100% {
                opacity: 1;
            }
        }
    </style>
</head>

<body>
    <div class="container">
        <header class="header">
            <h1><i class="fas fa-language"></i> LangAssist</h1>
            <div class="header-controls">
                <div class="status-indicator">
                    <div id="connDot" class="status-dot"></div>
                    <span id="connText">Unknown</span>
                </div>
                <button id="settingsBtn" class="btn btn-secondary">
                    <i class="fas fa-cog"></i> Settings
                </button>
                <button id="testConn" class="btn btn-primary">
                    <i class="fas fa-plug"></i> Test Connection
                </button>
            </div>
        </header>

        <div class="tabs">
            <div class="tab-header">
                <button class="tab active" data-tab="text"><i class="fas fa-edit"></i> Text Assist</button>
                <button class="tab" data-tab="voice"><i class="fas fa-microphone"></i> Voice Assistant</button>
                <button class="tab" data-tab="practice"><i class="fas fa-graduation-cap"></i> Practice Mode</button>
                <button class="tab" data-tab="responses"><i class="fas fa-history"></i> Responses</button>
            </div>

            <div id="text-content" class="tab-content active">
                <div class="form-row">
                    <div class="form-group">
                        <label for="action">Action</label>
                        <select id="action" class="form-control">
                            <option value="translate">Translate</option>
                            <option value="correct">Grammar Correction</option>
                            <option value="summarize">Summarize</option>
                            <option value="explain">Explain</option>
                            <option value="rephrase">Rephrase</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label for="tone">Tone/Style</label>
                        <select id="tone" class="form-control">
                            <option value="neutral">Neutral</option>
                            <option value="formal">Formal</option>
                            <option value="casual">Casual</option>
                            <option value="professional">Professional</option>
                            <option value="friendly">Friendly</option>
                        </select>
                    </div>
                </div>
                <div class="form-row">
                    <div class="form-group">
                        <label for="inputLang">Input Language</label>
                        <select id="inputLang" class="form-control">
                            <option value="auto">Auto-detect</option>
                            <option value="English">English</option>
                            <option value="Spanish">Spanish</option>
                            <option value="French">French</option>
                            <option value="German">German</option>
                            <option value="Italian">Italian</option>
                            <option value="Portuguese">Portuguese</option>
                            <option value="Russian">Russian</option>
                            <option value="Chinese">Chinese</option>
                            <option value="Japanese">Japanese</option>
                            <option value="Korean">Korean</option>
                            <option value="Hindi">Hindi</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label for="targetLang">Target Language</label>
                        <select id="targetLang" class="form-control">
                            <option value="English">English</option>
                            <option value="Spanish">Spanish</option>
                            <option value="French">French</option>
                            <option value="German">German</option>
                            <option value="Italian">Italian</option>
                            <option value="Portuguese">Portuguese</option>
                            <option value="Russian">Russian</option>
                            <option value="Chinese">Chinese</option>
                            <option value="Japanese">Japanese</option>
                            <option value="Korean">Korean</option>
                            <option value="Hindi">Hindi</option>
                        </select>
                    </div>
                </div>
                <div class="form-group">
                    <label for="userId">User ID (optional)</label>
                    <input type="text" id="userId" class="form-control" placeholder="Enter user identifier">
                </div>
                <div class="form-group">
                    <label for="textToProcess">Text to Process</label>
                    <textarea id="textToProcess" class="form-control"
                        placeholder="Enter your text here... (Ctrl+Enter to send)" rows="6"></textarea>
                </div>
                <div style="display: flex; gap: 10px; justify-content: flex-end;">
                    <button id="clearText" class="btn btn-secondary">
                        <i class="fas fa-eraser"></i> Clear
                    </button>
                    <button id="sendText" class="btn btn-primary">
                        <i class="fas fa-paper-plane"></i> Send
                    </button>
                </div>
            </div>

            <div id="voice-content" class="tab-content">
                <div class="recording-section">
                    <h3 style="margin-bottom: 15px;"><i class="fas fa-microphone"></i> Record Audio</h3>
                    <div class="recording-controls">
                        <button id="recBtn" class="btn btn-primary">
                            <i class="fas fa-record-vinyl"></i> Start Recording
                        </button>
                        <button id="stopRec" class="btn btn-danger" disabled>
                            <i class="fas fa-stop"></i> Stop
                        </button>
                        <span id="recTimer" class="recording-timer">00:00</span>
                    </div>
                    <div class="audio-meter">
                        <div id="meterFill" class="audio-meter-fill"></div>
                    </div>
                    <div class="recording-controls">
                        <button id="playRec" class="btn btn-secondary" disabled>
                            <i class="fas fa-play"></i> Play
                        </button>
                        <button id="downloadRec" class="btn btn-ghost" disabled>
                            <i class="fas fa-download"></i> Download
                        </button>
                        <div class="form-group" style="margin: 0; min-width: 120px;">
                            <select id="recordFormat" class="form-control">
                                <option value="webm">WebM</option>
                                <option value="wav">WAV</option>
                                <option value="ogg">OGG</option>
                            </select>
                        </div>
                    </div>
                </div>

                <div class="form-group">
                    <label for="audioFile">Or Upload Audio File</label>
                    <div class="file-input-wrapper">
                        <input type="file" id="audioFile" accept="audio/*" class="form-control">
                        <div class="btn btn-secondary" style="width: 100%; justify-content: center;">
                            <i class="fas fa-upload"></i> Choose Audio File
                        </div>
                    </div>
                    <small class="text-muted">Max file size: 10MB</small>
                </div>

                <div class="checkbox">
                    <input type="checkbox" id="useMultipart">
                    <label for="useMultipart">Use multipart/form-data (recommended for large files)</label>
                </div>

                <div style="display: flex; gap: 10px; justify-content: flex-end; margin-top: 20px;">
                    <button id="sendAudio" class="btn btn-primary">
                        <i class="fas fa-paper-plane"></i> Send Audio
                    </button>
                </div>
            </div>

            <div id="practice-content" class="tab-content">
                <div class="form-group">
                    <label for="practiceText">Text to Practice</label>
                    <textarea id="practiceText" class="form-control"
                        placeholder="Enter text you want to practice pronouncing..." rows="4"></textarea>
                </div>
                <div class="recording-controls">
                    <button id="startPractice" class="btn btn-primary">
                        <i class="fas fa-microphone"></i> Start Practice
                    </button>
                    <button id="stopPractice" class="btn btn-danger" disabled>
                        <i class="fas fa-stop"></i> Stop & Analyze
                    </button>
                </div>
                <div class="text-muted text-sm" style="margin-top: 15px;">
                    Enter the text you want to practice, then record yourself speaking it. The system will analyze your
                    pronunciation and provide feedback.
                </div>
            </div>

            <div id="responses-content" class="tab-content">
                <div class="responses-header">
                    <h2>Response History</h2>
                    <div class="responses-controls">
                        <div class="checkbox">
                            <input type="checkbox" id="rawToggle">
                            <label for="rawToggle">Raw JSON</label>
                        </div>
                        <div class="checkbox">
                            <input type="checkbox" id="showRaw">
                            <label for="showRaw">Show Raw Data</label>
                        </div>
                        <button id="playbackTTS" class="btn btn-secondary">
                            <i class="fas fa-play"></i> Play Last Response
                        </button>
                        <button id="downloadAll" class="btn btn-ghost">
                            <i class="fas fa-download"></i> Export All
                        </button>
                        <button id="clearResponses" class="btn btn-danger">
                            <i class="fas fa-trash"></i> Clear All
                        </button>
                        <span class="text-muted">Retries: <span id="retryCount">0</span></span>
                    </div>
                </div>
                <div id="responses"></div>
            </div>
        </div>
    </div>

    <div id="modal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2><i class="fas fa-cog"></i> Settings</h2>
                <button id="closeSettings" class="close-btn">&times;</button>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label for="settingWebhook">Webhook URL</label>
                    <input type="url" id="settingWebhook" class="form-control"
                        placeholder="https://your-n8n-instance.com/webhook/langassist">
                </div>
                <div class="form-group">
                    <label for="settingApiKey">API Key (optional)</label>
                    <input type="password" id="settingApiKey" class="form-control" placeholder="Your API key">
                </div>
                <div class="form-group">
                    <label for="settingLangs">Supported Languages (comma-separated)</label>
                    <input type="text" id="settingLangs" class="form-control" placeholder="English,Spanish,French">
                </div>
                <div class="form-group">
                    <label>Current Webhook:</label>
                    <div id="currentWebhook" class="webhook-display">(no webhook configured)</div>
                </div>
                <button id="settingsTest" class="btn btn-secondary">
                    <i class="fas fa-flask"></i> <span id="settingsPing">Test Connection</span>
                </button>
            </div>
            <div class="modal-footer">
                <button id="resetSettings" class="btn btn-secondary">
                    <i class="fas fa-undo"></i> Reset to Defaults
                </button>
                <button id="saveSettings" class="btn btn-primary">
                    <i class="fas fa-save"></i> Save Settings
                </button>
            </div>
        </div>
    </div>

    <script>
        (() => {
            const $ = sel => document.querySelector(sel);
            const id = s => document.getElementById(s);
            const SETTINGS_KEY = 'langassist.settings';
            const RESPONSES_KEY = 'langassist.responses';

            function loadSettings() {
                const defaultSettings = {
                    webhook: 'https://n8n-s73k.onrender.com/webhook-test/audio-echo',
                    apiKey: '',
                    langs: 'English,Spanish,Hindi'
                };

                try {
                    const stored = JSON.parse(localStorage.getItem(SETTINGS_KEY) || '{}');
                    return { ...defaultSettings, ...stored };
                } catch (e) {
                    return defaultSettings;
                }
            }

            function saveSettings(settings) {
                localStorage.setItem(SETTINGS_KEY, JSON.stringify(settings));
            }

            function loadResponses() {
                try {
                    return JSON.parse(localStorage.getItem(RESPONSES_KEY) || '[]');
                } catch (e) {
                    return [];
                }
            }

            function saveResponses(responses) {
                localStorage.setItem(RESPONSES_KEY, JSON.stringify(responses));
            }

            function isBinaryAudioData(obj) {
                if (!obj || typeof obj !== 'object') return false;

                // Check for n8n binary format with file property
                if (obj.file && obj.file.data && obj.file.mimeType) {
                    return obj.file.mimeType.startsWith('audio/') || obj.file.mimeType.startsWith('video/webm');
                }

                // Check for direct data with mimeType
                if (obj.data && obj.mimeType) {
                    return obj.mimeType.startsWith('audio/') || obj.mimeType.startsWith('video/webm');
                }

                if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
                    return true;
                }

                if (obj.binary && typeof obj.binary === 'object') {
                    return Object.values(obj.binary).some(item =>
                        item && item.mimeType && (item.mimeType.startsWith('audio/') || item.mimeType.startsWith('video/webm'))
                    );
                }

                if (obj.data && typeof obj.data === 'string' && obj.data.length > 100 && obj.mimeType) {
                    return obj.mimeType.startsWith('audio/') || obj.mimeType.startsWith('video/webm');
                }

                const keys = Object.keys(obj);
                if (keys.length < 50) return false;

                const numericKeys = keys.filter(k => /^\d+$/.test(k));
                if (numericKeys.length !== keys.length) return false;

                const indices = numericKeys.map(k => parseInt(k)).sort((a, b) => a - b);
                const isSequential = indices.length > 0 && indices[0] === 0;
                if (!isSequential) return false;

                for (let i = 1; i < Math.min(indices.length, 100); i++) {
                    if (indices[i] !== indices[i - 1] + 1) {
                        return false;
                    }
                }

                const sampleKeys = keys.slice(0, 20);
                const hasBytePattern = sampleKeys.every(k => {
                    const val = obj[k];
                    return typeof val === 'number' && val >= 0 && val <= 255 && Number.isInteger(val);
                });

                return hasBytePattern;
            }

            function detectAudioFormat(bytes) {
                if (bytes.length < 4) return 'audio/webm';

                const header = bytes.slice(0, 12);

                if (header[0] === 0x1A && header[1] === 0x45 && header[2] === 0xDF && header[3] === 0xA3) {
                    return 'audio/webm';
                }

                if (header[0] === 0x4F && header[1] === 0x67 && header[2] === 0x67 && header[3] === 0x53) {
                    return 'audio/ogg';
                }

                if (header[0] === 0x52 && header[1] === 0x49 && header[2] === 0x46 && header[3] === 0x46) {
                    return 'audio/wav';
                }

                if (header[0] === 0xFF && (header[1] & 0xE0) === 0xE0) {
                    return 'audio/mpeg';
                }

                if (header[4] === 0x66 && header[5] === 0x74 && header[6] === 0x79 && header[7] === 0x70) {
                    return 'audio/mp4';
                }

                if (header[0] === 0x66 && header[1] === 0x4C && header[2] === 0x61 && header[3] === 0x43) {
                    return 'audio/flac';
                }

                return 'audio/webm';
            }

            function convertBinaryDataToBlob(binaryData) {
                try {
                    let bytes = [];
                    let mimeType = 'audio/webm';

                    if (binaryData.binary && typeof binaryData.binary === 'object') {
                        const binaryKeys = Object.keys(binaryData.binary);
                        if (binaryKeys.length > 0) {
                            const firstBinary = binaryData.binary[binaryKeys[0]];
                            return convertBinaryDataToBlob(firstBinary);
                        }
                    }

                    if (binaryData.data && binaryData.mimeType) {
                        mimeType = binaryData.mimeType;

                        if (binaryData.data.type === 'Buffer' && Array.isArray(binaryData.data.data)) {
                            bytes = binaryData.data.data;
                        } else if (typeof binaryData.data === 'string') {
                            try {
                                const binaryString = atob(binaryData.data);
                                bytes = new Array(binaryString.length);
                                for (let i = 0; i < binaryString.length; i++) {
                                    bytes[i] = binaryString.charCodeAt(i);
                                }
                            } catch (e) {
                                console.warn('Failed to decode base64 data, treating as raw string');
                                bytes = Array.from(binaryData.data).map(c => c.charCodeAt(0));
                            }
                        } else if (typeof binaryData.data === 'object') {
                            const keys = Object.keys(binaryData.data).sort((a, b) => parseInt(a) - parseInt(b));
                            bytes = keys.map(k => binaryData.data[k]);
                        }

                        const uint8Array = new Uint8Array(bytes);
                        return new Blob([uint8Array], { type: mimeType });
                    }

                    if (binaryData.type === 'Buffer' && Array.isArray(binaryData.data)) {
                        bytes = binaryData.data;
                        const uint8Array = new Uint8Array(bytes);

                        if (bytes.length > 4) {
                            mimeType = detectAudioFormat(bytes);
                        }

                        return new Blob([uint8Array], { type: mimeType });
                    }

                    const keys = Object.keys(binaryData);
                    if (keys.every(k => /^\d+$/.test(k))) {
                        const sortedKeys = keys.sort((a, b) => parseInt(a) - parseInt(b));
                        bytes = sortedKeys.map(k => {
                            const val = binaryData[k];
                            return typeof val === 'number' && val >= 0 && val <= 255 ? Math.floor(val) : 0;
                        });

                        if (bytes.length === 0) {
                            throw new Error('No valid binary data found');
                        }

                        const uint8Array = new Uint8Array(bytes);

                        if (bytes.length > 4) {
                            mimeType = detectAudioFormat(bytes);
                        }

                        return new Blob([uint8Array], { type: mimeType });
                    }

                    throw new Error('Unrecognized binary data format');
                } catch (error) {
                    console.error('Error converting binary data to blob:', error, binaryData);
                    return null;
                }
            }

            let settings = loadSettings();
            let responses = loadResponses();
            let retryCount = 0;

            let mediaRecorder = null;
            let recordedChunks = [];
            let recStart = 0;
            let recTimerInterval = null;
            let analyser = null;
            let audioContext = null;

            let practiceRecorder = null;

            const connDot = id('connDot');
            const connText = id('connText');
            const currentWebhook = id('currentWebhook');
            const modal = id('modal');
            const responsesEl = id('responses');
            const retryCountEl = id('retryCount');

            function reflectSettings() {
                id('settingWebhook').value = settings.webhook || '';
                id('settingApiKey').value = settings.apiKey || '';
                id('settingLangs').value = settings.langs || '';
                currentWebhook.textContent = settings.webhook || '(no webhook configured)';
                updateConnStatus('unknown');
            }

            function updateConnStatus(state, msg) {
                const states = {
                    ok: { className: 'connected', text: 'Connected' },
                    fail: { className: 'error', text: 'Failed' },
                    unknown: { className: '', text: 'Unknown' }
                };
                const s = states[state] || states.unknown;
                connDot.className = `status-dot ${s.className}`;
                connText.textContent = s.text;
                if (msg) connText.title = msg;
            }

            document.querySelectorAll('.tab').forEach(tab => {
                tab.addEventListener('click', function () {
                    document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                    document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));

                    this.classList.add('active');

                    const tabName = this.getAttribute('data-tab');
                    const content = document.getElementById(tabName + '-content');
                    if (content) {
                        content.classList.add('active');
                    }
                });
            });

            async function pingWebhook() {
                if (!settings.webhook) {
                    updateConnStatus('fail', 'Webhook missing');
                    return { ok: false, message: 'no webhook' };
                }

                try {
                    id('settingsPing').textContent = 'Testing...';
                    const headers = { 'Content-Type': 'application/json' };
                    if (settings.apiKey) headers['x-api-key'] = settings.apiKey;

                    const res = await fetch(settings.webhook, {
                        method: 'POST',
                        headers,
                        body: JSON.stringify({ ping: true }),
                        mode: 'cors'
                    });

                    const text = await res.text();
                    id('settingsPing').textContent = res.ok ? 'Connection OK' : `Error (${res.status})`;
                    updateConnStatus(res.ok ? 'ok' : 'fail', text);
                    return { ok: res.ok, status: res.status, text };
                } catch (e) {
                    id('settingsPing').textContent = 'Connection Failed';
                    updateConnStatus('fail', e.message);
                    return { ok: false, error: e };
                }
            }

            id('settingsBtn').addEventListener('click', () => {
                modal.classList.add('active');
            });

            id('closeSettings').addEventListener('click', () => {
                modal.classList.remove('active');
            });

            id('saveSettings').addEventListener('click', () => {
                settings.webhook = id('settingWebhook').value.trim();
                settings.apiKey = id('settingApiKey').value.trim();
                settings.langs = id('settingLangs').value.trim();
                saveSettings(settings);
                reflectSettings();
                modal.classList.remove('active');
            });

            id('resetSettings').addEventListener('click', () => {
                localStorage.removeItem(SETTINGS_KEY);
                settings = loadSettings();
                reflectSettings();
            });

            id('settingsTest').addEventListener('click', () => {
                pingWebhook();
            });

            id('testConn').addEventListener('click', async () => {
                const result = await pingWebhook();
                if (result.ok) {
                    alert('Connection successful!');
                } else {
                    alert('Connection failed. Check your settings and ensure CORS is configured on your webhook.');
                }
            });

            function renderResponses() {
                if (!responses.length) {
                    responsesEl.innerHTML = '<div class="text-muted text-sm">No responses yet. Send a request to see results here.</div>';
                    return;
                }

                responsesEl.innerHTML = '';
                responses.slice().reverse().forEach((r, idx) => {
                    const item = document.createElement('div');
                    item.className = 'response-item';

                    const rawMode = id('rawToggle').checked || id('showRaw').checked;
                    let content = '';
                    let isBinaryAudio = false;

                    if (r.raw && isBinaryAudioData(r.raw)) {
                        isBinaryAudio = true;

                        if (rawMode) {
                            if (r.raw.data && r.raw.mimeType) {
                                const dataInfo = typeof r.raw.data === 'string' ? `Base64 string (${r.raw.data.length} chars)` :
                                    Array.isArray(r.raw.data) ? `Array (${r.raw.data.length} items)` :
                                        r.raw.data.type === 'Buffer' ? `Buffer (${Array.isArray(r.raw.data.data) ? r.raw.data.data.length : 'unknown'} bytes)` :
                                            'Object with numeric keys';

                                content = `[n8n Binary Audio Data]\n\nMimeType: ${r.raw.mimeType}\nData Info: ${dataInfo}\n\nStructure Preview:\n${JSON.stringify({
                                    mimeType: r.raw.mimeType,
                                    dataType: typeof r.raw.data,
                                    dataPreview: typeof r.raw.data === 'string' ? r.raw.data.substring(0, 100) + '...' :
                                        Array.isArray(r.raw.data) ? r.raw.data.slice(0, 10) :
                                            r.raw.data.type === 'Buffer' ? r.raw.data.data.slice(0, 10) :
                                                'Complex object'
                                }, null, 2)}`;
                            } else if (r.raw.type === 'Buffer') {
                                content = `[Buffer Audio Data]\n\nType: ${r.raw.type}\nSize: ${r.raw.data.length} bytes\n\nFirst 20 bytes: [${r.raw.data.slice(0, 20).join(', ')}...]`;
                            } else if (r.raw.binary) {
                                content = `[n8n Binary Object]\n\nBinary keys: ${Object.keys(r.raw.binary).join(', ')}\n\nStructure: ${JSON.stringify(r.raw, null, 2)}`;
                            } else {
                                const keys = Object.keys(r.raw);
                                content = `[Raw Binary Audio Data]\n\nTotal bytes: ${keys.length}\nData type: Numeric object with sequential keys\n\nFirst 20 bytes: [${keys.slice(0, 20).map(k => r.raw[k]).join(', ')}...]`;
                            }
                        } else {
                            let audioInfo = '';
                            let detectedFormat = 'Unknown';
                            let audioSize = 'Unknown';

                            if (r.raw.mimeType) {
                                detectedFormat = r.raw.mimeType;
                                audioInfo += `- Format: ${detectedFormat}\n`;
                            }

                            if (r.raw.data && r.raw.data.data && Array.isArray(r.raw.data.data)) {
                                audioSize = `${r.raw.data.data.length} bytes`;
                                audioInfo += `- Size: ${audioSize}\n`;

                                const actualFormat = detectAudioFormat(r.raw.data.data.slice(0, 12));
                                if (actualFormat !== 'audio/webm' && actualFormat !== detectedFormat) {
                                    audioInfo += `- Detected Format: ${actualFormat}\n`;
                                }
                            } else if (r.raw.type === 'Buffer' && r.raw.data) {
                                audioSize = `${r.raw.data.length} bytes`;
                                audioInfo += `- Size: ${audioSize}\n`;

                                const actualFormat = detectAudioFormat(r.raw.data.slice(0, 12));
                                audioInfo += `- Detected Format: ${actualFormat}\n`;
                            } else if (typeof r.raw === 'object') {
                                const keys = Object.keys(r.raw);
                                if (keys.every(k => /^\d+$/.test(k))) {
                                    audioSize = `${keys.length} bytes`;
                                    audioInfo += `- Size: ${audioSize}\n`;

                                    const byteArray = keys.slice(0, 12).map(k => r.raw[k]);
                                    const actualFormat = detectAudioFormat(byteArray);
                                    audioInfo += `- Detected Format: ${actualFormat}\n`;
                                }
                            }

                            content = `🎵 Audio Response Received\n\n${audioInfo}\nThis binary audio data was sent from your n8n workflow.\n\n✨ What you can do:\n• Click "Play Audio" button below to listen\n• Use "Download" to save the audio file\n• Toggle "Raw JSON" to see technical details`;
                        }
                    } else if (rawMode) {
                        try {
                            const rawCopy = { ...r.raw };
                            if (rawCopy.audioBase64 && typeof rawCopy.audioBase64 === 'string' && rawCopy.audioBase64.length > 100) {
                                rawCopy.audioBase64 = `[Base64 Audio Data - ${rawCopy.audioBase64.length} characters]`;
                            }
                            if (rawCopy.audio && typeof rawCopy.audio === 'string' && rawCopy.audio.length > 100) {
                                rawCopy.audio = `[Base64 Audio Data - ${rawCopy.audio.length} characters]`;
                            }
                            content = JSON.stringify(rawCopy, null, 2);
                        } catch (e) {
                            content = '[Could not parse response data]\n\n' + String(r.raw);
                        }
                    } else {
                        const parts = [];

                        if (r.raw && typeof r.raw === 'object') {
                            if (r.raw.processedText) parts.push('Processed Text:\n' + r.raw.processedText);
                            if (r.raw.translatedText) parts.push('Translation:\n' + r.raw.translatedText);
                            if (r.raw.summary) parts.push('Summary:\n' + r.raw.summary);
                            if (r.raw.feedback) parts.push('Feedback:\n' + r.raw.feedback);
                            if (r.raw.transcription) parts.push('Transcription:\n' + r.raw.transcription);
                            if (r.raw.text) parts.push('Text:\n' + r.raw.text);
                            if (r.raw.result) parts.push('Result:\n' + r.raw.result);
                            if (r.raw.score !== undefined) parts.push('Score: ' + r.raw.score);

                            if (r.raw.audioBase64 || r.raw.audio) {
                                parts.push('🎵 Audio file received - use "Play Last Response" button to listen');
                            }

                            Object.keys(r.raw).forEach(key => {
                                const excludeKeys = ['processedText', 'translatedText', 'summary', 'feedback', 'transcription', 'text', 'result', 'score', 'audioBase64', 'audio', 'audioContentType', 'data', 'mimeType', 'type'];
                                if (!excludeKeys.includes(key) && !(/^\d+$/.test(key))) {
                                    const value = r.raw[key];
                                    if (typeof value === 'string' && value.length > 500) {
                                        parts.push(`${key}: [Large text - ${value.length} characters]`);
                                    } else if (value !== null && value !== undefined) {
                                        parts.push(`${key}: ${JSON.stringify(value)}`);
                                    }
                                }
                            });
                        }

                        if (!parts.length) {
                            if (typeof r.raw === 'string') {
                                parts.push(r.raw);
                            } else {
                                parts.push(JSON.stringify(r.raw, null, 2));
                            }
                        }
                        content = parts.join('\n\n');
                    }

                    let responseHtml = `
                        <div class="response-header">
                            <div class="response-meta">
                                <span class="response-type">${r.action || r.type || 'response'}</span>
                                <span class="response-time">${new Date(r._ts || r.time).toLocaleString()}</span>
                            </div>
                            <span class="response-status ${r.ok ? 'success' : 'error'}">
                                ${r.ok ? 'OK' : 'Error'}
                            </span>
                        </div>`;

                    if (isBinaryAudio && !rawMode) {
                        responseHtml += `
                        <div class="binary-audio-indicator">
                            <i class="fas fa-music"></i>
                            <div>
                                <strong>Binary Audio File Detected</strong>
                                <div class="text-sm">Audio data received from n8n - Click "Play Audio" to listen</div>
                            </div>
                        </div>`;
                    }

                    responseHtml += `
                        <div class="response-content">${content}</div>
                        <div class="response-actions">
                            <button class="btn btn-ghost copy-btn">
                                <i class="fas fa-copy"></i> Copy
                            </button>
                            <button class="btn btn-ghost download-btn">
                                <i class="fas fa-download"></i> Download
                            </button>`;

                    if (isBinaryAudio) {
                        responseHtml += `
                            <button class="btn btn-ghost play-audio-btn">
                                <i class="fas fa-play"></i> Play Audio
                            </button>`;
                    }

                    responseHtml += `
                            <button class="btn btn-ghost delete-btn" data-index="${responses.length - 1 - idx}">
                                <i class="fas fa-trash"></i> Delete
                            </button>
                        </div>
                    `;

                    item.innerHTML = responseHtml;

                    const copyBtn = item.querySelector('.copy-btn');
                    const downloadBtn = item.querySelector('.download-btn');
                    const deleteBtn = item.querySelector('.delete-btn');
                    const playAudioBtn = item.querySelector('.play-audio-btn');

                    copyBtn.addEventListener('click', () => {
                        navigator.clipboard.writeText(content).then(() => {
                            copyBtn.innerHTML = '<i class="fas fa-check"></i> Copied!';
                            setTimeout(() => {
                                copyBtn.innerHTML = '<i class="fas fa-copy"></i> Copy';
                            }, 2000);
                        });
                    });

                    downloadBtn.addEventListener('click', () => {
                        if (isBinaryAudio) {
                            const audioBlob = convertBinaryDataToBlob(r.raw);
                            if (audioBlob) {
                                const url = URL.createObjectURL(audioBlob);
                                const a = document.createElement('a');
                                a.href = url;
                                a.download = `langassist-audio-${Date.now()}.webm`;
                                a.click();
                                URL.revokeObjectURL(url);
                            } else {
                                alert('Error converting audio data');
                            }
                        } else {
                            const blob = new Blob([content], { type: 'text/plain' });
                            const url = URL.createObjectURL(blob);
                            const a = document.createElement('a');
                            a.href = url;
                            a.download = `langassist-response-${Date.now()}.txt`;
                            a.click();
                            URL.revokeObjectURL(url);
                        }
                    });

                    deleteBtn.addEventListener('click', () => {
                        const index = parseInt(deleteBtn.dataset.index);
                        responses.splice(index, 1);
                        saveResponses(responses);
                        renderResponses();
                    });

                    if (playAudioBtn) {
                        playAudioBtn.addEventListener('click', () => {
                            playBinaryAudio(r.raw);
                        });
                    }

                    responsesEl.appendChild(item);
                });
            }

            async function playBinaryAudio(binaryData) {
                try {
                    const audioBlob = convertBinaryDataToBlob(binaryData);
                    if (!audioBlob) {
                        alert('Error converting binary data to audio');
                        return;
                    }

                    const url = URL.createObjectURL(audioBlob);
                    const audio = new Audio(url);

                    audio.onended = () => URL.revokeObjectURL(url);
                    audio.onerror = () => {
                        URL.revokeObjectURL(url);
                        alert('Error playing audio. The format may not be supported.');
                    };

                    await audio.play();
                } catch (error) {
                    alert('Error playing audio: ' + error.message);
                }
            }

            id('playbackTTS').addEventListener('click', async () => {
                const audioResponse = responses.slice().reverse().find(r => {
                    if (!r.raw) return false;
                    if (r.raw.audioBase64 || r.raw.audio) return true;
                    if (isBinaryAudioData(r.raw)) return true;
                    return false;
                });

                if (!audioResponse) {
                    alert('No audio response found.');
                    return;
                }

                try {
                    let audioBlob;

                    if (audioResponse.raw.audioBase64 || audioResponse.raw.audio) {
                        const b64 = audioResponse.raw.audioBase64 || audioResponse.raw.audio;
                        const contentType = audioResponse.raw.audioContentType || 'audio/mpeg';
                        audioBlob = base64ToBlob(b64, contentType);
                    } else if (isBinaryAudioData(audioResponse.raw)) {
                        audioBlob = convertBinaryDataToBlob(audioResponse.raw);
                    }

                    if (audioBlob) {
                        const url = URL.createObjectURL(audioBlob);
                        const audio = new Audio(url);

                        audio.onended = () => URL.revokeObjectURL(url);
                        audio.onerror = () => {
                            URL.revokeObjectURL(url);
                            alert('Error playing audio. The format may not be supported.');
                        };

                        await audio.play();
                    }
                } catch (error) {
                    alert('Error playing audio: ' + error.message);
                }
            });

            id('clearResponses').addEventListener('click', () => {
                responses = [];
                saveResponses(responses);
                renderResponses();
            });

            id('downloadAll').addEventListener('click', () => {
                const blob = new Blob([JSON.stringify(responses, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'langassist-responses.json';
                a.click();
                URL.revokeObjectURL(url);
            });

            async function sendToWebhook(payload, meta = {}) {
                if (!settings.webhook) {
                    alert('No webhook configured. Please open Settings and add one.');
                    return;
                }

                const headers = {};
                if (settings.apiKey) headers['x-api-key'] = settings.apiKey;

                try {
                    let res, raw;
                    const useMultipart = id('useMultipart') && id('useMultipart').checked;

                    if (useMultipart && meta.formData) {
                        res = await fetch(settings.webhook, {
                            method: 'POST',
                            headers: { ...headers },
                            body: meta.formData
                        });
                        raw = await tryParseResponse(res);
                    } else if (useMultipart && meta.blob) {
                        const fd = new FormData();
                        fd.append('file', meta.blob, meta.filename || 'recording.webm');
                        fd.append('payload', JSON.stringify(payload));
                        res = await fetch(settings.webhook, {
                            method: 'POST',
                            headers: { ...headers },
                            body: fd
                        });
                        raw = await tryParseResponse(res);
                    } else {
                        const body = { ...payload };
                        if (meta.blob) {
                            const b64 = await blobToBase64(meta.blob);
                            body.file = {
                                filename: meta.filename || 'recording.webm',
                                contentType: meta.blob.type || 'application/octet-stream',
                                base64: b64
                            };
                        }
                        res = await fetch(settings.webhook, {
                            method: 'POST',
                            headers: { ...headers, 'Content-Type': 'application/json' },
                            body: JSON.stringify(body)
                        });
                        raw = await tryParseResponse(res);
                    }

                    const entry = {
                        ok: res.ok,
                        status: res.status,
                        raw,
                        action: meta.action || payload.action || 'unknown',
                        time: Date.now(),
                        type: meta.type || 'request',
                        _ts: Date.now()
                    };

                    responses.push(entry);
                    saveResponses(responses);
                    renderResponses();

                    if (!res.ok) {
                        retryCount++;
                        retryCountEl.textContent = retryCount;
                    }
                } catch (err) {
                    const entry = {
                        ok: false,
                        status: 'network',
                        raw: String(err),
                        action: meta.action || payload.action,
                        time: Date.now(),
                        _ts: Date.now()
                    };
                    responses.push(entry);
                    saveResponses(responses);
                    renderResponses();
                    retryCount++;
                    retryCountEl.textContent = retryCount;
                }
            }

            async function tryParseResponse(res) {
                const ct = res.headers.get('content-type') || '';
                try {
                    if (ct.includes('application/json')) return await res.json();
                    return await res.text();
                } catch (e) {
                    try {
                        return await res.text();
                    } catch (e2) {
                        return null;
                    }
                }
            }

            function buildPayload(base) {
                return {
                    ...base,
                    meta: {
                        app: 'LangAssist',
                        version: '1.1',
                        timestamp: Date.now()
                    }
                };
            }

            async function submitText() {
                const payload = buildPayload({
                    action: id('action').value,
                    tone: id('tone').value,
                    inputLang: id('inputLang').value,
                    targetLang: id('targetLang').value,
                    userId: id('userId').value || null,
                    text: id('textToProcess').value
                });
                await sendToWebhook(payload, { type: 'text', action: payload.action });
            }

            id('sendText').addEventListener('click', submitText);
            id('clearText').addEventListener('click', () => {
                id('textToProcess').value = '';
            });

            id('textToProcess').addEventListener('keydown', (e) => {
                if (e.key === 'Enter' && (e.ctrlKey || e.metaKey)) {
                    e.preventDefault();
                    submitText();
                }
            });

            async function startRecording() {
                if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                    alert('Media recording not supported in this browser');
                    return;
                }

                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    const source = audioContext.createMediaStreamSource(stream);
                    analyser = audioContext.createAnalyser();
                    analyser.fftSize = 256;
                    source.connect(analyser);

                    recordedChunks = [];
                    const format = id('recordFormat').value || 'webm';
                    const mimeType = format === 'wav' ? 'audio/wav' : (format === 'ogg' ? 'audio/ogg' : 'audio/webm');

                    mediaRecorder = new MediaRecorder(stream, { mimeType });
                    mediaRecorder.ondataavailable = (e) => {
                        if (e.data && e.data.size) recordedChunks.push(e.data);
                    };

                    mediaRecorder.onstop = async () => {
                        const blob = new Blob(recordedChunks, { type: recordedChunks[0] ? recordedChunks[0].type : mimeType });
                        id('playRec').disabled = false;
                        id('downloadRec').disabled = false;

                        window._lastRecording = {
                            blob,
                            filename: 'recording.' + format,
                            ext: format
                        };

                        stream.getTracks().forEach(track => track.stop());
                    };

                    mediaRecorder.start(250);
                    recStart = Date.now();
                    recTimerInterval = setInterval(updateTimer, 200);
                    updateMeter();

                    id('recBtn').disabled = true;
                    id('stopRec').disabled = false;
                } catch (e) {
                    alert('Could not start recording: ' + e.message);
                }
            }

            function updateTimer() {
                const elapsed = Math.floor((Date.now() - recStart) / 1000);
                const mm = String(Math.floor(elapsed / 60)).padStart(2, '0');
                const ss = String(elapsed % 60).padStart(2, '0');
                id('recTimer').textContent = `${mm}:${ss}`;
            }

            function updateMeter() {
                if (!analyser) return;
                const data = new Uint8Array(analyser.frequencyBinCount);
                analyser.getByteFrequencyData(data);
                const rms = Math.sqrt(data.reduce((s, v) => s + v * v, 0) / data.length);
                const pct = Math.min(100, Math.round(rms));
                id('meterFill').style.width = pct + '%';
                if (mediaRecorder && mediaRecorder.state === 'recording') {
                    requestAnimationFrame(updateMeter);
                }
            }

            function stopRecording() {
                if (mediaRecorder && mediaRecorder.state === 'recording') {
                    mediaRecorder.stop();
                }
                id('recBtn').disabled = false;
                id('stopRec').disabled = true;
                clearInterval(recTimerInterval);
                id('meterFill').style.width = '0%';
            }

            function playRecording() {
                const rec = window._lastRecording;
                if (!rec) {
                    alert('No recording available');
                    return;
                }
                const url = URL.createObjectURL(rec.blob);
                const audio = new Audio(url);
                audio.play();
                setTimeout(() => URL.revokeObjectURL(url), 60000);
            }

            function downloadRecording() {
                const rec = window._lastRecording;
                if (!rec) {
                    alert('No recording available');
                    return;
                }
                const url = URL.createObjectURL(rec.blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = rec.filename;
                a.click();
                URL.revokeObjectURL(url);
            }

            id('recBtn').addEventListener('click', startRecording);
            id('stopRec').addEventListener('click', stopRecording);
            id('playRec').addEventListener('click', playRecording);
            id('downloadRec').addEventListener('click', downloadRecording);

            id('audioFile').addEventListener('change', (e) => {
                const f = e.target.files[0];
                if (!f) return;
                if (f.size > 10 * 1024 * 1024) {
                    alert('File too large (max 10MB)');
                    id('audioFile').value = '';
                    return;
                }
            });

            id('sendAudio').addEventListener('click', async () => {
                const f = id('audioFile').files[0];
                const useMultipart = id('useMultipart') && id('useMultipart').checked;

                if (f) {
                    if (f.size > 10 * 1024 * 1024) {
                        alert('File too large (10MB max)');
                        return;
                    }

                    if (useMultipart) {
                        const fd = new FormData();
                        fd.append('file', f, f.name);
                        fd.append('payload', JSON.stringify({ action: 'transcribe', type: 'upload', timestamp: Date.now() }));
                        await sendToWebhook({}, { formData: fd, action: 'upload', type: 'audio' });
                    } else {
                        await sendToWebhook(
                            { action: 'transcribe', type: 'upload', timestamp: Date.now() },
                            { blob: f, filename: f.name, action: 'upload', type: 'audio' }
                        );
                    }
                } else if (window._lastRecording && window._lastRecording.blob) {
                    const rec = window._lastRecording;
                    if (useMultipart) {
                        const fd = new FormData();
                        fd.append('file', rec.blob, rec.filename);
                        fd.append('payload', JSON.stringify({ action: 'transcribe', type: 'recording', timestamp: Date.now() }));
                        await sendToWebhook({}, { formData: fd, action: 'recording', type: 'audio' });
                    } else {
                        await sendToWebhook(
                            { action: 'transcribe', type: 'recording', timestamp: Date.now() },
                            { blob: rec.blob, filename: rec.filename, action: 'recording', type: 'audio' }
                        );
                    }
                } else {
                    alert('No audio file selected or recorded.');
                }
            });

            id('startPractice').addEventListener('click', async () => {
                id('startPractice').disabled = true;
                id('stopPractice').disabled = false;

                if (!navigator.mediaDevices) {
                    alert('Media recording not supported');
                    id('startPractice').disabled = false;
                    id('stopPractice').disabled = true;
                    return;
                }

                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    practiceRecorder = new MediaRecorder(stream);
                    const chunks = [];

                    practiceRecorder.ondataavailable = e => {
                        if (e.data && e.data.size) chunks.push(e.data);
                    };

                    practiceRecorder.onstop = async () => {
                        const blob = new Blob(chunks, { type: chunks[0] ? chunks[0].type : 'audio/webm' });
                        await sendToWebhook(
                            { action: 'pronunciation_score', text: id('practiceText').value, timestamp: Date.now() },
                            { blob, filename: 'practice.webm', action: 'practice' }
                        );
                        id('startPractice').disabled = false;
                        id('stopPractice').disabled = true;
                        stream.getTracks().forEach(track => track.stop());

                        id('startPractice').innerHTML = '<i class="fas fa-microphone"></i> Start Practice';
                    };

                    practiceRecorder.start();

                    id('startPractice').innerHTML = '<i class="fas fa-circle" style="color: red; animation: pulse 1s infinite;"></i> Recording...';

                } catch (e) {
                    alert('Could not start practice recording: ' + e.message);
                    id('startPractice').disabled = false;
                    id('stopPractice').disabled = true;
                    id('startPractice').innerHTML = '<i class="fas fa-microphone"></i> Start Practice';
                }
            });

            id('stopPractice').addEventListener('click', () => {
                if (practiceRecorder && practiceRecorder.state === 'recording') {
                    practiceRecorder.stop();
                }
            });

            function blobToBase64(blob) {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = () => resolve(reader.result.split(',')[1]);
                    reader.onerror = reject;
                    reader.readAsDataURL(blob);
                });
            }

            function base64ToBlob(b64, mimeType) {
                const byteCharacters = atob(b64);
                const byteNumbers = new Array(byteCharacters.length);
                for (let i = 0; i < byteCharacters.length; i++) {
                    byteNumbers[i] = byteCharacters.charCodeAt(i);
                }
                const byteArray = new Uint8Array(byteNumbers);
                return new Blob([byteArray], { type: mimeType });
            }

            id('rawToggle').addEventListener('change', renderResponses);
            id('showRaw').addEventListener('change', renderResponses);

            modal.addEventListener('click', (e) => {
                if (e.target === modal) {
                    modal.classList.remove('active');
                }
            });

            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape' && modal.classList.contains('active')) {
                    modal.classList.remove('active');
                }
            });

            reflectSettings();
            renderResponses();
            retryCountEl.textContent = retryCount;

            setTimeout(() => {
                pingWebhook();
            }, 1000);

            window.langassist = {
                sendToWebhook,
                settings,
                saveSettings,
                loadSettings,
                responses,
                saveResponses,
                isBinaryAudioData,
                convertBinaryDataToBlob,
                playBinaryAudio,
                detectAudioFormat
            };
        })();
    </script>
</body>

</html>